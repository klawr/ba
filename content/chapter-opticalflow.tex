\chapter{Ermittlung des optischen Flusses}

Die wahrgenommene Bewegung hervorgerufen durch zwei Bilder in welcher die enthaltenen Objekte sich relativ zu einander Bewegen zu scheinen wird als \name{optischer Fluss}(zu engl. \name{Optical Flow}) bezeichnet. // TODO Zitat aus Modern AI, S. 939 unten.
Inspiriert durch diesen Ansatz scheint es naheliegend ihn auf planare Mechanismen anzuwenden um so aus einer Videoaufnahme, oder mehrerer Bildaufnahmen eines Mechanismus diesen synthetisieren zu können.

% Hier ein Bild von Thomas Brox scheint angebracht. (Modern AI S. 941)

\name{Optical Flow} Methoden können genutzt werden um ein Vektorfeld mit Position, Richtung und Geschwindigkeit der sich bewegenden Pixel zu identifizieren.

Innerhalb der sich bewegenden Pixel sollen nun die Gruppen ermittelt werden, welche sich trotz absoluter Bewegung sich nicht relativ zueinander bewegen.
Ebenso sind Vektoren zu gruppieren, dessen Bewegungen sich homogen zueinander zu verhalten scheinen, es also davon ausgegangen werden kann, dass diese zu einem Glied gehören.

Bei einem stationärem Schwungpendel wäre es zu erwarten, dass die absolute Geschwindigkeit der Pixel um den Drehpunkt gering ist und linear zum Abstand des Drehpunktes zunimmt.
Ein Vergleich der Richtungsvektoren sollte allerdings mit entsprechender Skalierung gleich sein, sodass eine Gruppierung hier eindeutig ist.

Diese Gruppen können dann weiter daraufhin untersucht werden ob sie sich innerhalb bestimmter Rahmenbedingungen zueinander bewegen.
Das bedeutet, ob sie umeinander rotieren, oder gegebenenfalls die Gruppe selber sich in ihrer Länge ändert, was einer translatorischen Bewegung zugeordnet werden kann.

\section{Erkennung eines einfachen Pendels}

\subsection{Definition des animierten Pendels}

Für den Anfang wird versucht ein mit \name{mec2} erstelltes Pendel zu rekonstruieren.
Hierfür wird eine einfache HTML Seite erstellt, welche HTML-\code{canvas} Elemente enthält um die Versuche zu visualisieren und entsprechende \code{script} Felder um das \name{JavaScript} einzubetten.
Das Pendel wird durch Listing~\ref{lst:pendel} definiert, was in einem einfachem schwingendem Pendel resultiert.

\begin{lstlisting}[language=JavaScript, caption={Definition eines einfachen Pendels in \name{mec2}, inklusive animation.}\label{lst:pendel}]
const model = {
    id: 'pendulum',
    gravity: true,
    nodes: [
        { id: 'A0', x: 150, y: 120, base: true },
        { id: 'A1', x: 230, y: 150 }
    ],
    constraints: [
        { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
    ]
};

mec.model.extend(model); // extend the model
model.init();            // initialize it
model.draw(g);           // append model-graphics to graphics-obj
simulate();              // kick-off the simulation
\end{lstlisting}

Das Pendel besteht entsprechend aus zwei \code{nodes}, welche die Gelenkpunkte darstellen.
Eine dieser beiden Gelenkpunkte wird als \code{base} deklariert, was bedeutet sie ist unbeweglich und damit stellt sie den Punkt dar um welchen das Pendel schwingt.

Um das Pendel entsprechend zu animieren wird der Programmcode genutzt der auf der Dokumentationsseite \aka{https://goessner.github.io/mec2/microjam.md/getting_started.html} hinterlegt ist genutzt.

Innerhalb der \code{simulate} Funktion wird \code{requestAnimationFrame(simulate)} aufgerufen, damit der nächste Zeitschritt der Animation ablaufen kann.

\subsection{Erkennung von Änderungen}

Um die Bewegung innerhalb einer Bildsequenz zu erkennen werden zunächst zwei Bilder miteinander verglichen, welche zeitlich etwa 16,7 Millisekunden auseinanderliegen.
Die Frequenz von \name{requestAnimationFrame} beträgt im Optimalfall\footnote{Das bedeutet das keine Berechnungen länger als 16,7 Millisekunden benötigen, welche die Animation entsprechend verlangsamen würde.} 60 Hertz.

Da sich in der modellierten Videosequenz nur das Pendel bewegt, reicht es aus die Bilder pixelweise zu vergleichen und die Koordinaten der ungleichen Pixel zu behalten um somit all jene zu bekommen welche ungleich sind.
Hierfür wurde die \code{simulate} Function, welche in Listing~\ref{lst:pendel} gezeigt wurde mit dem Programmcode aus Listing~\ref{lst:simulate_compare_images} versehen.

\begin{lstlisting}[language=JavaScript, caption={TODO caption....}\label{lst:simulate_compare_images}]
const simulate = () => {
    model.tick(1 / 60); // solve model with fixed stepping
    g.exe(ctx);         // render its pose on the canvas

    const image1 = ctx.getImageData(
        0, 0, cnv.width, cnv.height).data;

    window.setTimeout(() => {
        const image2 = ctx.getImageData(
            0, 0, cnv.width, cnv.height).data;
        const result = compare_images(
            image1, image2, cnv.width, cnv.height);
    }

    g2().clr().exe(dtx);
    for (let i = 0; i < result.length; ++i) {
        const zone = result[i];

        g2().clr().cir({x: zone.x, y: zone.y, r: 1}).exe(dtx);
    }
};
\end{lstlisting}

Wobei \code{ctx} und \code{dtx} den \code{RenderingContext} des jeweiligen \code{canvas} Element repräsentieren.
\code{compareImages} wird in Listing~\ref{lst:compare_images} gezeigt.

\begin{lstlisting}[language=JavaScript, caption={Definition der \code{compare_images} Function}\label{lst:compare_images}]
function compare_images(image1, image2, width, height) {
const difference = [];

for (let y = 0; y < height; ++y) {
    for (let x = 0; x < width; ++x) {
        const i = y * width + x;
        if (image1[i * 4] !== image2[i * 4]) {
            difference.push({x, y});
        };
    }
}

return difference;
}
\end{lstlisting}

Eine Momentaufnahme dieser Konstruktion kann in Abbildung~\ref{fig:compare_images} gesehen werden.

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{gfx/compare_images_1.png}
	\caption{Darstellung des Pendels und die dazugehörige erkannte Änderung innerhalb des Bildes.}
	\label{fig:compare_images}
\end{figure}

Zu beachten ist, dass das Pendel zwei mal gezeigt wird.
Das liegt daran, dass wenn die beiden Bilder verglichen werden, genau jene Pixel unterschiedlich sind an denen das Pendel im ersten Bild ist und im zweiten nicht mehr ist und genau dort wo das Pendel im zweiten Bild ist und im ersten nicht.
Ohne weitere Analyse lässt sich jedoch nicht so einfach bestimmen welche Änderung aus welchem Bild stammt.
Für die anschließende Untersuchung kann diese Tatsache ignoriert werden, allerdings ist es wichtig solche Besonderheiten zu betrachten um mögliche Fehlerquellen schneller zu finden.

Diese Punkte können dazu genutzt werden um einen Kreis zu definieren, indem das \name{Smallest Enclosing Circle Problem} gelöst wird.
Hierfür werden alle Pixel gespeichert an denen eine Änderung betrachtet wird.
Beginnt das Pendel mit dem Schwingen ändert sich der Mittelpunkt des ermittelten Kreises sehr schnell.
Sobald das Pendel jedoch mindestens einen Halbkreis vollzieht steht der Mittelpunkt mit Ausnahme von ein paar Fluktuationen fest.
Aus diesem Grund werden als Metrik die letzten zehn Mittelpunkte des Kreises behalten und die Summe der Abstände dieser Punkte bestimmt.
Sobald diese Summe den Wert null erreicht, wird davon ausgegangen mit einer gewissen Zuversicht den richtigen Mittelpunkt gefunden zu haben.

Sobald der Mittelpunkt des Pendels gefunden wurde, kann das andere Ende des Pendels bestimmt werden, indem der vom Mittelpunkt am weitesten entfernte Punkt gefunden wird.

Um den Fehler zu zeigen den das ermittelte Pendel in Bezug auf den bestimmten Winkel hat wird nun, nachdem die Bestimmung des Drehpunktes geschehen ist, der entsprechende Winkel mit dem von \name{mec2} zur Verfügung gestellten Winkel des Gliedes verglichen.
Hierfür wird bei jeder Iteration der Winkel zwischen dem Endpunkt und dem Mittelpunkt berechnet und der tatsächliche Winkel davon abgezogen und einer Liste hinzugefügt die dann als ein Graph dargestellt werden kann, welcher in Abbildung~\ref{fig:pendel_prediction} betrachtet werden kann.

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{gfx/compare_images_2.png}
	\caption{Darstellung des Pendels und dem dazugehörigen erkannten Pendel. Der Graph zeigt den Fehler des Winkels über die Zeit an. Die X-Achse zeigt die vergangene Zeit in Sekunden ab dem Zeitpunkt der Ermittlung des Mittelpunktes an, die Y-Achse zeigt den berechneten Fehler in Radiant, welcher nach dem ersten halben Intervall bei etwa 0.15 liegt was in etwa 9° entspricht.}
	\label{fig:pendel_prediction}
\end{figure}

Dieser Ansatz leidet jedoch unter dem Problem, dass um den Drehpunkt zu bestimmen das Glied mindestens eine halbe Umdrehung vollführen muss.
Der kleinste umfassende Kreis für die Punkte darunter wäre erheblich kleiner als der tatsächliche Kreis, weshalb ein anderer Ansatz zur Bestimmung des Mittelpunktes gewählt werden muss.

% TODO hier sollten noch Bilder hin und vllt auch vorher ein Bild bei der Beschreibung wie der kleinste umfassende Kreis berechnet wird?

\section{TODO} %TODO ein Titel für dieses Kapitel wäre gut...

Als ein neuer Ansatz zum berechnen des Mittelpunktes soll versucht werden Anhand der Änderungen innerhalb der Bilder die Linien zu finden welche am ehesten die Menge der Punkte repräsentiert welche ermittelt wurden.
Dieses Vorgehen basiert auf der Annahme, dass die Glieder eines Mechanismus einen größeren Radius haben als sie in jede andere Richtung gehen.

Die Definition dieser Linie wird gespeichert um mit anderen Linien verglichen welche in weiteren Iterationen gemessen wird.
Der Schnittpunkt zweier Linien sollte dann innerhalb einer akzeptablen Toleranz des tatsächlichen Drehpunkt des Mechanismus entsprechen.

Dieser Ansatz hat des weiteren den Vorteil, dass er nach nur zwei Iterationen bereits ein hinreichendes Ergebnis liefern kann\footnote{Das sind entsprechend drei Bilder die in den Vergleichen genutzt werden müssen.}.

Der direkte Ansatz ist die zwei Punkte zu ermitteln dessen Distanz zueinander den höchsten Wert hat.
Der Code zum Vergleichen der Bilder kann hierbei größtenteils aus dem vorherhigen Ansatz übernommen werden.
Hierfür wird bei jeder Iteration bei der zwei aufeinanderfolgende Bilder verglichen werden, wie in Listing~\ref{lst:compare_images} gesehen kann.
Problematisch stellt sich jedoch die Unregelmäßigkeit vor mit der die Pixel ermittelt werden in denen Änderungen erkannt werden.
So liegen die beiden Punkte die am weitesten voneinander entfernt sind nicht auf der tatsächlichen Linie die das Pendel darstellen würde, sondern soweit davon entfernt, dass die sich daraus ermittelbare Steigung erheblich vom echten Wert unterscheidet.
Entsprechend stellt der Schnittpunkt zweier auf diese Weise ermittelten Linien nicht den Drehpunkt des Gliedes dar.

\begin{figure}[htb]
	\includegraphics[width=\textwidth]{gfx/max_abstand_steigung differenz.png}
	\caption{Die grüne Linie des linken Graphen stellt den Winkel des Pendels modulo Pi dar, während die orangene Linie  den Arkustangens der Steigung (ebenfalls modulo Pi) darstellt. Der rechte Graph stellt den berechneten Fehler dar, der einige male gegen den Wert von Pi ausschlägt, sonst jedoch relativ niedrig ist. Trotzdem sind dort vereinzelt auch weitere Fehler zu erkennen, welche mitigiert werden sollten.}
	\label{fig:max_abstand_steigung differenz}
\end{figure}

Ein Ansatz dieses Problem zu umgehen ist statt die Linien zweier direkt aufeinanderfolgender Vergleiche zu betrachtet, diejenigen Linien zu vergleichen dessen Winkel untereinander am größten ist.
Sobald der gewanderte Winkel größer ist als ein Halbkreis, kann wieder der Ansatz aus Kapitel~\ref{} % TODO Closest endinging circle in eigenes Kapitel packen. Generell mehr subchapter nutzen um besser referenzieren zu können.
gewählt werden um den Mittelpunkt zu bestimmen.

Allerdings ist die Varianz der Winkel auch hier wieder so groß, dass die Bestimmung der am meisten auseinanderliegenden Winkel nicht eindeutig ist.
Entsprechend muss ein anderer Ansatz gewählt werden um die Linien zu bestimmen anhand derer die Steigung bemessen wird.

\subsection{Ermittlung der am besten passenden Linie}

Die Aufgabe die am besten zu der Menge an gefunden Punkten passende Linie zu finden kann durch die Methode der kleinsten Quadraten gelöst werden.
% Hier ausführlich erklären wie diese Methode funktioniert.

Jedoch entsteht auch mit dieser Methode wieder ein weiteres Problem.
Wenn zwei Bilder die eine Drehung darstellen miteinander verglichen werden, indem jene Pixel behalten werden in denen eine Änderung zu erkennen ist, dann werden typischerweise mehr Änderungen erkannt, je weiter man sich radial von Drehpunkt entfernt.
Diese Beobachtung ist nicht überraschend, denn die absolute Geschwindigkeit eines Gelenkes nimmt mit länge des Gliedes zu, allerdings verzerrt es die Beobachtung ein wenig.
Hier kann jedoch eine Funktion abhilfe schaffen, die auch in der Bilderkennung durch neurale Netzwerke genutzt wird.
Diese als Non-Max Suppression % TODO writing...
bezeichnete Funktion wird eigentlich dafür genutzt, dass erkannte Objekte die im Bild direkt nebeneinander liegen gefiltert werden für das Bild, dass den höchsten Konfidenzwert besitzt.
Da den Pixeln hier kein Konfidenzwert zugeordnet werden kann, kann allerdings eine Funktion genutzt werden welche ähnlich wie die Non-Max Suppression Funktion %TODO oh mann...
die sich überlappenden Pixel in einem bestimmten Umkreis entfernt.
Dadurch wird die Dichte der erkannten Pixel quasi homogen und der Drehpunkt liegt etwas näher an dem tatsächlich erkannten, ohne viel Präzision bei der Bestimmung der Steigung in Kauf zu nehmen.

Der nächste Schritt ist entsprechend die Schnittpunkte der erkannten Linien zu definieren und daraus den Drehpunkt zu ermitteln.


% TODO etwas praktischer werden und dann erst zeigen warum das kacke war.

% TODO das muss irgendwo untergebracht werden, bevor ich auf die Gruppierung gehe...
Des weiteren basiert dieser Ansatz auf der Annahme, dass alle Änderungen der Bilder die verglichen werden zu dem selben Glied gehören.
Da die Definition eines Mechanismus mindestens 3 bewegliche Glieder benötigt, muss auch hier ein anderer Ansatz genutzt werden. % TODO cite

% http://personal.kent.edu/~rmuhamma/Compgeometry/MyCG/CG-Applets/Center/centercli.htm


% NOTES:
% Performance increase through "superpixels", superpixels klingt nach etwas, was ich auch haben will. Siehe: Contour Detection and Hierarchical Image Segmentation