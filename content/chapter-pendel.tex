\chapter{Rekonstruktion eines Pendels}

Statt der vollständigen Rekonstruktion eines Mechansimus, soll zunächst mit einem einfachen Pendel begonnen werden.
Dieses stellt im Grunde ein einzelnes Glied eines beliebigen Mechanismus dar.
Die korrekte Erkennung eines Pendels ist also eine notwendige Bedingung für einen Ansatz der die Glieder des Mechanismus einzeln betrachtet\footnote{Das gilt im Grunde für alle Mechanismen welche rotierende Elemente beinhalten. Für alle Glieder welche keine Absolutpole besitzen sei die Relativbewegung gegenüber solchen heranziehbar}.

Als zentrales Ziel dieses Kapitels wird die korrekte Bestimmung des Drehpunkts eines Pendels gesetzt; es sei jedoch angemerkt, dass ein Drehpunkt lediglich einen Sonderfall der Bestimmung des Momentanpols darstellt, auf dessen Bestimmung in % TODO
näher eingegangen wird.
Zunächst wird die Erkennung des Drehpols als vereinfachtes Ziel genommen um herauszufinden, welche Information man durch die Beobachtung eines sich bewegenden Elementes gewinnen kann.

Für die Bestimmung des Endpunktes wird zunächst der Punkt genommen, der am weitesten vom Drehpunkt ist.
Diese Annahme ist für den Anfang hinreichend und wird im Zuge der Zusammensetzung mehrerer Glieder hinfällig. % TODO wieso? ja weil man dann die Schnittpunkt der Glieder, bzw. die Relativpole nimmt. Aber das soll erstmal geschrieben werden bevor ich hier schon rumposaune dass das geht.

\section{Erstellung der Tests}

\subsection{Die index.html}

Die Testseiten sind jeweils eigenständige HTML-Seiten welche über das HTML-Iframe Element in einer zentralen Testseite nebeneinander untersucht werden können.
Die Tests sind widerrum gruppiert in einzelne zu untersuchende Fragmente.
Für diese Gruppierung wurde in der \name{index.html} ein \lstinline{tests} Objekt definiert welches Information über die entsprechenden Gruppen bereithält.

Dieses Testobjekt wird in Listing~\ref{lst:tests_objekt}

\begin{lstlisting}[language=JavaScript, caption={Definition des \lstinline{tests} Objekts in der \name{index.html} mit etwas gekürztem \lstinline{title}.}\label{lst:tests_objekt}]
const tests = {
    pendel: {
        title: "Tests zum Finden des Drehpunkts...",
        indices: [5, 5, 2]
    },
    momentanpol: {
        title: "Tests zur Ermittlung des Momentanpols...",
        indices: [3, 2]
},
    gruppe: {
        title: "Tests zum Segmentieren der Datenpunkte ...",
        indices: [2, 1, 1, 3]
    },
}
\end{lstlisting}

In diesem \lstinline{tests} Objekt ist die festgehalten, welche Gruppen es gibt, wie diese betitelt werden und die \lstinline{indices} Eigenschaft der einzelnen Eigenschaften bezeichnen wie viele Tests diese Gruppe jeweils bereitstellt.

Für diese \lstinline{indices} ist die Ordnerstruktur des Projektes von Bedeutung.
Jede Eigenschaft des \lstinline{tests} Objekts hat im \name{src} Ordner relativ zum Root-Verzeichnis einen entsprechenden Ordner.
Dieser enthält die einzelnen HTML-Testseiten welche ebenfalls nach einem festen Schema benannt sind.
So ist der relative Pfad zum Root-Verzeichnis eines Tests \name{src/[Gruppe]/[Gruppe][Index1]\_[Index2].html}.
Der erste Test ist also unter dem Relativpfad \name{src/pendel/pendel1\_1.html} zu finden.

Dieser zunächst komplex wirkende Aufbau erlaubt es allerdings alle Tests durch Listing~\ref{lst:tests_objekt_reason} in die \name{index.html} einbauen.

\begin{lstlisting}[language=JavaScript, caption={Iteration über das tests Objekt zur Population der index.html.}\label{lst:tests_objekt_reason}]
Object.entries(tests).forEach((kv, i) => {
    const title = document.createElement('h2');
    title.innerHTML = kv[1].title;
    const summary = document.createElement('summary');
    const details = document.createElement('details');

    kv[1].indices.forEach((e, j) => {
        const innerSummary = document.createElement('summary');
        const innerDetails = document.createElement('details');
        innerSummary.innerHTML = `${kv[0] + (j + 1)}`;
        innerDetails.appendChild(innerSummary);
        details.appendChild(innerDetails);

        for (let m = 1; m <= e; ++m) {
            const iframe = document.createElement('iframe');
            iframe.src = `src/${kv[0]}/${kv[0]+(j + 1)}_${m}.html`;
            innerDetails.appendChild(iframe);
        }
    });
    summary.innerHTML = kv[1].title;
    details.appendChild(summary);
    document.body.appendChild(details);
});
\end{lstlisting}

Hier wird für jeden Eintrag im \lstinline{tests} Objekt ein neues HTML-Details Element erstellt. % TODO MDN link?
Über die \lstinline{indices} Eigenschaft der einzelnen Einträge wird dann iteriert um die einzelnen Gruppen gemeinsam in ein weiteres HTML-Details Element zu platzieren.
Über den Wert der einzelnen Elemente der \lstinline{indices} Liste wird dann festgestellt wie viele HTML-Iframe Elemente erstellt werden sollen und welchen Pfad diese als Quelle (\lstinline{src}) nehmen sollen.

Damit die Seite eine anständige Formatierung besitzt wurden die entsprechenden Elemente durch CSS gestaltet, worauf hier jedoch nicht weiter eingegangen werden soll.

\subsection{simulation.js}\label{ch:simulation_js}

Die Anforderungen an die Tests ist grundlegend gleich.
Deshalb ist es sinnvoll den meisten Programmcode in einer zentralen Datei abzulegen, welche dann durch jede Testdatei eingebunden werden soll.
Diese Datei wurde als \name{simulation.js} bezeichnet.

In \name{simulation.js} wird das \lstinline{globalTestVariables} Objekt definiert.
Dieses Objekt soll dazu dienen die genutzten globalen Variablen zu begrenzen.
Es beinhaltet alle Referenzen zu den HTML-Elementen auf welche im Zuge der Tests zugegriffen werden könnten, sowie den Referenzen zu den einzelnen \name{CanvasRenderingContext2D} Objekten welche von \name{g2} genutzt werden um auf die entsprechenden HTML-Canvas Elemente zu zeichnen.
Außerdem werden globale Konstanten wie unter Anderem die Höhe und Breite der HTML-Canvas Elemente hier zentral bestimmt.

Des Weiteren werden im \lstinline{globalTestVariables} Objekt mehrere wichtige Funktionen definiert.
Auf diese Funktionen soll im nachfolgenden näher eingegangen werden um zu verstehen wie sie die Testseiten zusammensetzen.
Alle nachfolgenden Funktionen sind als Eigenschaften des \lstinline{globalTestVariables} Objektes zu verstehen.

\subsubsection{createElements}\label{ch:gtv_createElements}

Die HTML-Elemente welche innerhalb der Testseiten verwendet werden sind grundsätzlich stets die gleichen.
Aus dem Grund beschreibt die \lstinline{createElements} Funktion die Befüllung der Testseiten mit den entsprechenden HTML-Elementen.
So muss bei entsprechendem Wunsch zur Änderung nur an dieser zentralen Stelle beispielsweise das \lstinline{innerHTML} eines Elementes geändert werden.
Außerdem werden in dieser Funktion die Eigenschaften von \lstinline{globalTestVariables} gesetzt, welche zunächst undefiniert sind.

% TODO wie sieht denn jetzt die Seite aus?

\subsubsection{run}\label{ch:gtv_run}

Die \lstinline{run} Funktion trägt Sorge dafür, dass alle Tests unter den selben Konditionen aufgerufen werden.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{globalTestVariables.run} Funktion.}\label{lst:gtv_run}]
    run(step) {
        this.model?.tick(1 / 60);
        this.g.exe(this.ctx1);
        this.time_reset = performance.now();
        step();
        this.updateTimesChart().exe(this.ctx_times);
    
        if (this.running) {
            this.rafId = requestAnimationFrame(() => {
                this.run(step)
            });
        }
    },
\end{lstlisting}

Sollte ein \name{mec2} Modell definiert sein, dann soll dieses an dieser Stelle seine \lstinline{tick} Funktion anwenden, damit es um einen Zeitschritt weiter iteriert wird.
Hierbei wird davon ausgegangen, dass wenn ein \name{mec2} Modell auf dem \lstinline{globalTestVariables} Objekt definiert ist, dieses zur Animation verwendet werden soll.
Innerhalb der Testfunktionen sollte dieses Modell jedoch nicht modifiziert werden, da es als Quelle für die Bildsequenzen dient.

Anschließend wird der \name{CanvasRenderingContext2D} des ersten der vier HTML-Canavs Elemente \lstinline{ctx1} beschrieben.
Dieser sollte ausschließlich hier beschrieben werden, damit der Test nicht versehentlich Einfluss auf die Zeichnung nimmt.
Es soll eine grundlegende Prämisse sein, dass die gesuchte Funktion zur Bestimmung des Mechanismus ausschließlich Anhand der Bildsequenzen funktioniert und selbst keinen Einfluss auf diese hat.

Nachdem der HTML-Canvas gezeichnet wurde, wird eine an \lstinline{run} übergebene Funktion, welche hier als \lstinline{step} step deklariert ist, ausgeführt.
Diese Funktion ist durch den Test selber definiert und führt alle Vergleiche und Berechnungen aus welche durchgeführt werden sollen.
Diese an die an \lstinline{run} übergebenen Funktionen werden in den entsprechenden Kapiteln für die Tests beschrieben.

Abschließend wird hier noch die Zeit welche diese \lstinline{step} benötigt vermerkt, indem \lstinline{updateTimesChart} aufgerufen wird.
In \lstinline{updateTimesChart} wird der aktuelle Zeitpunkt mittels \lstinline{performance.now()} % TODO MDN Link oder besser erklären.
ermittelt und in einer Liste hinzugefügt welche die Historie der Geschwindigkeiten der einzelnen \lstinline{step} Aufrufe festhält.
Es wird außerdem gemessen wie viel Zeit seit dem Beginn der Aufzeichnung vergangen ist, sodass eine sinnvolle Bezeichnung der Achsen der Graphen möglich sind.
Dieser Graph wird anschließend auf einem HTML-Canvas Element durch den \lstinline{exe(ctx_times)} Aufruf gezeichnet.

Nachdem anschließend geprüft wurde ob der Test weiter laufen soll \footnote{\lstinline{running} kann beispielsweise durch einen Start/Stop Knopf umgeschaltet werden.} wird die \lstinline{run} Funktion wird erneut durch \lstinline{requestAnimationFrame} aufgerufen.

\subsubsection{register}\label{ch:gtv_register}

\lstinline{register} ist die Funktion, welche von den einzelnen Tests aufgerufen wird um die HTML-Seite zu befüllen und den Test zu injizieren.

Hier wird zunächst der Titel festgelegt, welcher dem Namen der HTML-Datei entspricht.
Dieser Titel wird in einem HTML-Anker Element % MDN Link
platziert, damit diese in der \name{index.html} einfacher zugeordnet werden können.
Es dient außerdem als Hyperlink, der genutzt werden kann um isoliert auf den Test zuzugreifen.

An dieser Stelle wird außerdem ein Knopf erzeugt, welcher das Laden des Tests ermöglicht und \lstinline{createElement} ausführt.
Sollte ein \name{mec2} Modell definiert sein, so wird hier die \lstinline{mec.model.extend} Funktion mit diesem aufgerufen und dann dessen \lstinline{init} Funktion bemüht um dieses zu instanzieren. % TODO mec2 Link?

Wenn der Test geladen wird, wird die Simulation vorbereitet und es wird einmalig die \lstinline{run} Funktion aufgerufen um das erste Bild zu zeigen\footnote{Da \lstinline{globalTestVariables.running} initial den Wert \lstinline{false} hat wird innerhalb des \lstinline{run} Aufrufs \lstinline{requestAnimationFrame} nicht bemüht.}.
Die \lstinline{register} Funktion erwartet die Funktion welche an \lstinline{run} als Argument übergeben wurde selbst als Argument.
Damit wird diese Funktion von \lstinline{register} lediglich an \lstinline{run} weitergegeben.

Hier wird außerdem noch die Erstellung des Knopfes zum Starten und Pausieren der Tests definiert.
Die Betätigung dieses Knopfes resultiert in einem Umschalten der \lstinline{globalTestVariables.running} Variable und dem Ausführen von \lstinline{run}.

Das \lstinline{globalTestVariables} Objekt enthält noch weitere Variablen und Funktionen welche Einfluss auf den Ablauf der Tests haben.
Um die Beschreibung hier jedoch auf das wesentliche zu reduzieren, sei hier auf die Definition des kompletten Objektes im Quellcode %TODO Link
hingewiesen.

% TODO irgendwo erklären wieso diese one-definition rule sinnvoll ist. Besser noch die odr selber erklären.

\subsection{Aufbau der Testseiten}

Die HTML-Seiten wurden einheitlich gestaltet, sodass an diesen nicht viel geändert werden muss um weitere Tests zu definieren.
Sie unterscheiden sich untereinander vorallem durch die unterschiedlichen Dateien welche eingebunden werden um die Tests auszuführen.
Die eingebundenen Dateien beinhalten unter anderem in jedem Test die \name{g2.full.js}, \name{mec2.min.js} und die \name{simulation.js}.

Neben diesen wurden jedoch viele Skripte geschrieben welche sich einzelne Tests teilen.
Zum Beispiel jene zum definieren von Linien oder Punktwolken, welche auf diese Weise einheitlich mit solchen umgehen können.

Des weiteren enthalten Gruppen an Tests weitere geteilte globale Variablen, welche \lstinline{globalTestVariables} für diese Tests erweitern sollen.

Diese HTML-Seiten enthalten außerdem noch jeweils ein HTML-Paragraph Element % TODO Link, 
in welchem beschrieben wird was in dem entsprechenden Versuch untersucht wird.

Für die weitere Strukturierung der Testseiten wurde die \lstinline{globalTestVariables.createElements} Funktion definiert, welche die HTML-Seiten befüllt.
Diese Funktion wurde in Kapitel~\ref{ch:gtv_createElements} beschrieben, es soll hier noch darauf eingegangen werden was für Elemente von ihr erstellt werden.

Die vier erstellten HTML-Canvas Elemente sollen in jedem Versuch jeweils vergleichbare Rollen übernehmen.

Das erste dieser Elemente dazu verwendet den getesteten Algorithmus mit Bildern zu versorgen auf dessen Basis dieser dann den entsprechenden Mechanismus rekonstruieren soll.

Das zweite HTML-Canvas Element soll genutzt werden um zu visualisieren was in einem Versuch getestet wird.
Diese Visualisierung soll dazu dienen einen besseren Eindruck davon zu bekommen ob die darunterliegenden Funktionen funktionieren und ob Erkenntnisse daraus gezogen werden können.

Das dritte HTML-Canvas Element dient zur Auswertung der ermittelten Daten.
In den meisten Tests wird dieses Element dazu genutzt um die ermittelten Koordinaten in einem Graphen darzustellen und diesen dann nach weiteren Erkenntnissen zu untersuchen.

Die Aufgabe das zweite und dritte HTML-Canvas Element zu befüllen wird durch die Funktionenen welche jeweils getestet werden selbst durchgeführt.
Sie dienen entsprechend lediglich der Untersuchung der Ansätze und spielen für die Entwicklung eines abschließenden Verfahrens keine Rolle.

Das befüllen des vierten HTML-Canvas Elementes wurde bereits in Kapitel~\ref{ch:gtv_run} ausführlich beschrieben.

\subsection{Definition eines \name{mec2} Modells}

In vielen der im Nachfolgenden beschriebenen Tests werden \name{mec2} Modelle verwendet.
Aus diesem Grund soll hier die Definition eines einfach Pendels beschrieben werden, welches für die ersten Tests so oder leicht abgewandelt verwendet wird.
Es wird durch den Drehpunkt, den Endpunkt und dessen konstante Länge zueinander definiert.
Bewegt wird das Pendel, sofern es keinen Antrieb hat, lediglich durch das Gewicht des Endpunktes, da durch die Annahme von geschwichtslosen Gliedern diese keinen Einfluss haben.
Entsprechend wird in den \name{mec2} Simulationen Gravitation simuliert.
Auf einen Antrieb wurde in den ersten Tests zunächst verzichtet, weil dieser für die Erkennung der Bewegung nicht notwendig ist.

Ein Beispiel für die Definition eines solchen Modells für \name{mec2} wird in Listing~\ref{lst:pendel} gezeigt.

\begin{lstlisting}[language=JavaScript, caption={Definition eines einfachen Pendels in \name{mec2}, inklusive animation.}\label{lst:pendel}]
globalTestVariables.model = {
    gravity: true,
    nodes: [
        { id: 'A0', x: 150, y: 100, base: true },
        { id: 'A1', x: 230, y: 130 }
    ],
    constraints: [
        { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
    ]
};
\end{lstlisting}

Das \name{mec2} Modell wird in der entsprechenden Testdatei  auf dem \lstinline{globalTestVariables} Objekt definiert, damit dieses in den in Kapitel~\ref{ch:simulation_js} beschriebenen Funktionen korrekt referenziert werden kann.
Es ist also notwendig die \name{simulation.js} vor dieser Definition einzubinden, da dies sonst undefiniert ist.

Das Pendel besteht entsprechend aus zwei \lstinline{nodes}, welche die Endpunkte des Pendels darstellen.
Einer dieser beiden Punkte wird als \lstinline{base} deklariert.
Das hat zur Folge, dass es unbeweglich ist, womit es den Drehpunkt, beziehungsweise Absolutpol des Pendels darstellt.
Aus diesem regulären JavaScript Objekt wird ein \name{mec2} Modell, indem es durch \lstinline{mec.model.extend} erweitert wird.
Dieser Vorgang wurde bereits in Kapitel~\ref{ch:gtv_register} beschrieben.
Die Animation wird durch die \lstinline{globalTestVariables.run} Funktion gesteuert, welche ebenfalls in Kapitel~\ref{ch:gtv_run} beschrieben wurde.

\section{Erkennung von Änderungen} \label{ch:erkennung_von_änderungen}

Um die Bewegung innerhalb einer Bildsequenz zu erkennen werden hier stets zwei Bilder miteinander verglichen, welche zeitlich etwa 16,7 Millisekunden auseinanderliegen.
Die Frequenz von \name{requestAnimationFrame} beträgt im Optimalfall 60 Hertz.
Dieser Optimalfall sei dadurch definiert, dass die \lstinline{step} Funktion aus \lstinline{run} (s. Listing~\ref{lst:gtv_run}) weniger als 16,7 Millisekunden benötigt\footnote{Neben der an \lstinline{run} übergebenen \lstinline{step} Funktion werden natürlich noch andere Funktionen wie \lstinline{model.tick} und \lstinline{updateTimesChart} ausgeführt, diese sollen hier jedoch nicht betrachtet werden. Sie werden daher auch für die Zeitmessung innerhalb von \lstinline{run} ausgeschlossen.}.

\subsection{compareImages}

Da sich in der modellierten Videosequenz nur das Pendel bewegt, reicht es aus die Bilder pixelweise zu vergleichen und die Koordinaten der ungleichen Pixel aufzuzeichnen.
Hierfür wurde eine Funktion \lstinline{stepCompareImages} definiert, welche durch eine an die \lstinline{register} Funktion übergebene Funktion aufgerufen wird.

Diese Funktion ruft den aktuellen Inhalt des ersten HTML-Canvas Elementes durch \lstinline{cnv1.getContext('2d').getImageData(0, 0, cnv1.width, cnv1.height).data} auf und vergleicht diesen mit dem Bild vom letzten Aufruf.
Da der erste Aufruf dieser Funktion keinen Vergleich mit einem vorangegangen Bild zulässt, wird geprüft ob ein solches existiert.

Die \lstinline{compareImages} Funktion vergleicht dann zwei Bilder auf unterschiede indem die beiden Bilder auf Unterschiede untersucht werden.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{compareImages} Funktion.}\label{lst:pendel}]
function compareImages(image1, image2, width, height) {
    const difference = [];

    for (let y = 0; y < height; ++y) {
        for (let x = 0; x < width; ++x) {
            const i = y * width + x;
            if (image1[i * 4] !== image2[i * 4]) {
                difference.push({ x, y });
            };
        }
    }

    return difference;
}
\end{lstlisting}

Diese Funktion speichert eine \lstinline{difference} Liste, welche jeweils Objekte mit den Koordinaten von gefundenen Unterschieden speichert.

Dieser Ansatz zeichnet sich durch seine Einfachheit aus, hat aber offensichtliche Nachteile.

So würden Änderungen durch Objekte welche trotz Bewegung auf dem Bild für einen Pixel keine Farbänderung verursachen dort keine Änderungen erkannt werden.
Es werden also nur dort Änderungen erkannt, wo sich die Farbe des entsprechenden Pixels ändert.

Es ist außerdem zu beachten, dass dadurch das die reine Änderung der Pixel betrachtet wird jedes sich bewegende Objekt zwei mal dargestellt wird.
Das liegt daran, dass wenn die beiden Bilder verglichen werden, genau jene Pixel unterschiedlich sind an denen das Pendel im ersten Bild ist und im zweiten nicht mehr ist und genau dort wo das Pendel im zweiten Bild ist und im ersten nicht.
Ohne weitere Analyse lässt sich jedoch nicht so einfach bestimmen in welche Richtung sich das Pendel bewegt.

Außerdem ist mit dieser Methode nicht von einer exakten Abmessung auzugehen, sondern die ermittelten Koordinaten ergeben eher eine Art Punktwolke bei der von einem hohen Maß an Unregelmäßigkeit auszugehen ist.

Es sei an dieser Stelle jedoch lediglich auf diese Nachteile hingewiesen, sodass diese bei Betrachtungen der Ergebnisse berücksichtigt werden können.

An die \lstinline{stepCompareImages} Funktion kann widerrum eine Funktion übergeben werden, welche dann mit den gesammelten Koordinaten der \lstinline{compareImages} Funktion aufgerufen werden kann.

Diese Sammlung an Koordinaten wird verwendet um sie auf Regelmäßigkeiten zu untersuchen.
Wie bereits angemerkt, wird als erstes versucht ein Pendel zu rekonstruieren.
Im nachfolgenden wurden unterschiedliche Ansätze darauf untersucht, mit welcher Performanz und Genauigkeit sie dies machen.

\section{Betrachtung unterschiedlicher Ansätze}

\subsection{Bestimmung des kleinsten umfassenden Kreises}

Wie bereits vorher angemerkt, werden die Koordinaten aller Pixel aufgezeichnet für die bei einer Bewegung eine Änderung bemerkt wurde.
Diese Pixel sollten bei der Drehung eines Gliedes um einen festen Punkt einen Bogen definieren, der Aufschluss über die Position dieses Drehpunktes gibt.

Die genaue Bestimmung eines solchen Bogens durch Mittelpunkt, Radius und eingeschlossenem Winkel anhand der Punktwolke zu ermitteln erscheint zunächst schwierig.
Stattdessen wird beim ersten untersuchten Ansatz der kleinste Kreis bestimmt, welcher alle bisher gesammelten Datenpunkte umfasst.

Den kleinsten umfassenden Kreis zu ermitteln ist ein Problem für das ein Algorithmus existiert welcher in linearer Zeit\footnote{Das heißt die Dauer des Algorithmus steht in linearem Verhältnis zur Menge der Datenpunkte} durchgeführt werden kann.
Der entsprechende Algorithmus wurde von Nimrod Megido~\cite{Megiddo1983} entwickelt und die Implementation wird von \aka{https://github.com/nayuki/Nayuki-web-published-code/blob/master/smallest-enclosing-circle/smallest-enclosing-circle-demo.js} bezogen.
% TODO hier könnte noch etwas vom Algorithmus erzählt werden.
% TODO ein Hinweis auf die Demo von Nayuki ist vielleicht auch noch sinnvoll: https://www.nayuki.io/page/smallest-enclosing-circle

\subsubsection{pendel1\_1.html}

Um einen solchen Kreis zu bestimmen müssen zunächst alle Koordinaten für die eine Änderung erkannt wurde in einer Liste festgehalten werden.

Da zu Beginn der Aufnahme die Region welche durch die Punkte gefüllt wird sehr schnell an Fläche zunimmt, ändern sich die Koordinaten und der Radius des Mittelpunktes des kleinsten umfassenden Kreises.
Sobald sich das drehende Glied einer halben Umdrehung nähert verändert sich die Definition des kleinsten umfassenden Kreises augenscheinlich garnicht mehr und dessen Mittelpunkt scheint mit einer sehr kleinen Abweichung dem tatsächlichen Drehpunkt zu entsprechen.

Entsprechend wird bei diesem Versuch 

Das andere Ende des Pendels wird vorerst durch den Punkt definiert dessen Distanz die größte zum prognostizierten Drehpunkt ist.
Dies dient nur zur besseren Visualisierung des erkannten Modells und ist für die eigentliche Aufgabe vorerst irrelevant, da ein Pendel noch keinen Mechanismus darstellt.

% TODO Bild.

Bisher wurden zur Ermittlung des kleinsten umfassenden Kreises aller bisher ermittelten Datenpunkte alle Datenpunkte verwendet.
Dies ist jedoch nicht notwendig, da die Kreise welche über den zeitlichen Verlauf hinweg gebildet werden nur jene Datenpunkte behalten werden müssen, welche zur Erstellung des Kreises notwendig sind.
Dies sind je nach Verteilung der Punktwolke entweder drei oder lediglich zwei Punkte.
Dafür wurde der genutzte Algorithmus angepasst, sodass er nicht mehr nur den Kreis, sondern auch die entsprechenden Koordinaten zurückgibt, welche für die Erstellung des entsprechenden Kreises genutzt wurden\footnote{Die entsprechende Änderung kann auf \aka{https://github.com/klawr/ba/commit/7209dfee5ab0a70470e22862f26f7c45046cd98f} nachvollzogen werden}.
Außerdem wird bei der Ermittlung des Kreises zwischen den bereits bekannten und der aktuell ermittelten Punktwolke unterschieden, sodass bei der Erweiterung der Liste der bekannten Punkte diese nicht mehrfach hinzugefügt werden.

% TODO wurde überhaupt schon eingeführt, dass es solche Tests gibt? Und wie die so aussehen? Man könnte außerdem hier davon sprechen wie ich diesen Test gemacht habe. Ich habe einfach in simulation unter step ein: 
% let counter = 0;
% function step(fn) {
%     counter++;
%     if (counter > 60) {
%         running = false;
%         console.log(ply.length)
%     }
% eingebaut. Das ist auch so ungefähr eine halbe Schwingung.
Diese Anpassung reduziert die Menge der Punkte die im ersten Test in einer Sekunde ermittelt werden von 19880 auf 294 Datenpunkte.
Von diesen 294 Datenpunkten sind lediglich 69 den bekannten Datenpunkten zuzuordnen.
Die anderen 225 Punkte lassen sich den gemessenen Veränderungen der letzten beiden verglichenen Bildern zuordnen, was in etwa dem Durchschnitt der Punkte in diesen Tests entspricht.
Ein weiterer Vorteil ergibt sich noch dadurch, dass Glieder welche sich mehrfach im selben Winkel befinden keine neuen Einträge zu den bekannten Punkten hinzufügen.
Ohne diesen Filter würde die Menge der Datenpunkte linear zunehmen, und die Dauer des Algorithmus, dessen Zeit ebenfalls linear zur Menge der Datenpunkte wächst, quadratisch wachsen.

% TODO Vergleich der Performance.

% TODO check das ° Zeichen ob das anständig gedruckt wird.
Dieser Ansatz erkennt für ein Glied das sich mindestens 180° um den definierten Punkt dreht ein sehr nahe am tatsächlichen Wert gelegenen Drehpunkt.
Der offensichtliche Nachteil besteht jedoch darin, dass alle Glieder die sich um weit weniger als 180° drehen mit Sicherheit kein gutes Ergebnis liefern.

Die Veränderung des Mittelpunktes des Kreises für den Bogen mit kleinerem Mittelpunktswinkel kann jedoch Aufschluss darüber geben, wo sich der tatsächliche Drehpunkt womöglich befinden könnte.
Diese Möglichkeit soll als nächstes untersucht werden.
% TODO Untersuch das.

% TODO Gerade Linie und dann Kreis.
% TODO Abhängigkeit von Bedeckter Fläche
% TODO Ermittlung von Schnittpunkten durch die geraden
% TODO Kathetensatz nach Euklid, welcher über h und q das b ermitteln kann, welches durch den Satz von Thales auf das a schließen kann welches mit q einen Schnittpunkt in B haben muss, wobei B bekanntenmaßen der Drehpunkt ist.
% TODO Das sollte bei steigendem h und q eine immer genauere Prognose von B geben können.

\subsection{Schnittpunkte von Linien}

Als ein weiterer Ansatz soll untersucht werden, ob der Drehpunkt durch die Schnittpunkte von ermittelten Linien gefunden werden kann.
Diese Linie soll durch die Momentaufnahmen bestimmt werden.

Als erster Ansatz soll die Linie genutzt werden, welche durch die am weitesten voneinander entfernten Punkte definiert wird.
Diese Linie sollte in etwa den selben Winkel haben wie der Winkel des tatsächlichen Gelenkes.
Eine Annahme die hierbe implizit getroffen wird, ist dass die Glieder länger sind als sie breit sind, wobei die Länge durch den Abstand der Gelenke definiert ist und die Breite entsprechend durch die Punkte welche normal zu der Längenlinie stehen.

Eine auf diese Weise definierte Linie wird dann in einer Liste gespeichert und die nächste Iteration folgt.
Bereits ab der zweiten Iteration können dann die Schnittpunkte aller Linien genutzt werden um den Drehpunkt zu bestimmen.

% TODO Koordinaten der einzelnen Schnittpunkte betrachten. X und Y sollten im Grunde eine Normalverteilung aufweisen. Dann muss auch nicht der Schwerpunkt genommen werden... Ist aber vermutlich weniger Rechenintensiv.

Idealerweise sollten alle Schnittpunkte die selben Koordinaten haben.
Da dies jedoch nicht der Fall ist, wird der Schwerpunkt aller Schnittpunkte ermittelt und dieser soll dann als Prognose benutzt werden.

Diese Methode liefert schnell Ergebnisse auch für Mittelpunktswinkel von weit unter 180°.

% /subsection{Ermittlung mehrerer am weitesten auseinander liegenden Punkte}.

Nachteilig ist jedoch, dass der Winkel durch die am weitesten voneinander entfernten Punkte sehr stark variiert, da wie in Abschnitt~\ref{ch:erkennung_von_änderungen} bereits erwähnt, bei dem Vergleich zweier zeitlich aufeinander folgenden Bilder sowohl die Position des ersten, als auch die Position des Pendels im zweiten Bild enthalten ist.
Um dieses Problem zu Umgehen sollen nun mehrere am weitesten auseinander liegenden Punkte ermittelt werden und die Prozedur mit diesen wiederholt werden.

% TODO hier sollte ein Bild vorher zu nachher eingefügt werden um diese Aussage zu untermauern.
Durch diese Änderung entspricht der jeweilige Winkel der definierten Linien eher dem tatsächlichen Winkel und der entsprechend resultierende Fehler wird hierdurch kleiner.
Damit reduziert sich auch die Abweichung zum daraus errechneten Drehpunkt.

\subsection{Methode der kleinsten Quadrate}

Eine weitere Methode jene Linie zu bestimmen welche genutzt werden soll um mit dessen Schnittpunkte den Drehpunkt zu ermitteln ist durch die \name{Methode der kleisten Quadrate}.
Die Linie die aus der Lösung dieser Methode resultiert entspricht der Linie welche den kleinsten Fehler gegenüber allen Punkten besitzt und wird auch als Ausgleichsgerade bezeichnet. % TODO Ist von Wiki sollte aber zitiert werden...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TODO Writing

Jedoch entsteht auch mit dieser Methode wieder ein weiteres Problem.
Wenn zwei Bilder die eine Drehung darstellen miteinander verglichen werden, indem jene Pixel behalten werden in denen eine Änderung zu erkennen ist, dann werden typischerweise mehr Änderungen erkannt, je weiter man sich radial von Drehpunkt entfernt.
Diese Beobachtung ist nicht überraschend, denn die absolute Geschwindigkeit eines Gelenkes nimmt mit länge des Gliedes zu, allerdings verzerrt es die Beobachtung ein wenig.
Hier kann jedoch eine Funktion abhilfe schaffen, die auch in der Bilderkennung durch neurale Netzwerke genutzt wird.
Diese als Non-Max Suppression % TODO writing...
bezeichnete Funktion wird eigentlich dafür genutzt, dass erkannte Objekte die im Bild direkt nebeneinander liegen gefiltert werden für das Bild, dass den höchsten Konfidenzwert besitzt.
Da den Pixeln hier kein Konfidenzwert zugeordnet werden kann, kann allerdings eine Funktion genutzt werden welche ähnlich wie die Non-Max Suppression Funktion %TODO oh mann...
die sich überlappenden Pixel in einem bestimmten Umkreis entfernt.
Dadurch wird die Dichte der erkannten Pixel quasi homogen und der Drehpunkt liegt etwas näher an dem tatsächlich erkannten, ohne viel Präzision bei der Bestimmung der Steigung in Kauf zu nehmen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Auch die Ausgleichsgerade basiert auf der Annahme, dass das betrachtete Glied länger ist als es breit ist.

Sie berechnet sich durch... % TODO
% TODO Formel.

Die vorgeschlagene Formel funktioniert nicht gut für nahezu senkrechte Steigungen.
Dies liegt an... % TODO
Deshalb wurde die Formel für alle Winkel über 45° angepasst, sodass die im Nenner die jeweilige Differenz zum Durchschnitt der Y-Achse berechnet wird.
Zum Spiegeln der Achsen werden außerdem der Zähler und Nenner zur Bestimmung der Steigung vertauscht.

% TODO Formel.

Wie bei den vorangegangen Methoden sollen dann die Schnittpunkte der so errechneten Linien genutzt werden um den Drehpunkt zu bestimmen.

\subsection{Vergleich zweier Kreise}

Die letzte Methode die untersucht werden soll ist\dots

\subsection{Auswertung der Beobachtungen}

% TODO Statistik Gedöhns und Beschreibung der unterschiedlichen Vor- und Nachteile

Die hier besprochenen Ansätze teilen die Annahme, das alle Punkte welche durch die Änderung betrachtet wurden zu dem selben Glied gehören.
Des weiteren wird davon ausgegangen, dass alle Glieder einen Drehpunkt haben.
Da die Definition eines Mechanismus mindestens 3 bewegliche Glieder benötigt, muss hierfür eine Lösung gefunden werden, die im folgenden Abschnitt untersucht wird.

