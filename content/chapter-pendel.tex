\chapter{Rekonstruktion eines Pendels}

\cleanchapterquote{Was kann ich wissen?\\Was soll ich tun?\\Was darf ich hoffen?}{Immanuel Kant}{Kritik der reinen Vernunft}

Das erste Problem das hier untersucht werden soll ist welche Information aus dem Abgleich von Bildern in Bildsequenzen gewonnen werden kann und wie man daraus gewonnene Erkenntnisse auf die zugrundeliegenden mechanismentechnische Strukturen zurückführen kann.
Deshalb wird statt der vollständigen Rekonstruktion eines Mechansimus zunächst mit einem einfachen Pendel begonnen.
Dieses stellt im Grunde ein einzelnes Glied eines beliebigen Mechanismus dar.
Die korrekte Erkennung eines Pendels ist also eine notwendige Bedingung für einen Ansatz der die Glieder des Mechanismus einzeln betrachtet\footnote{Das gilt im Grunde für alle Mechanismen welche rotierende Elemente beinhalten. Für alle Glieder welche keine Absolutpole besitzen sei die Relativbewegung gegenüber solchen heranziehbar}.

Als zentrales Ziel dieses Kapitels wird die korrekte Bestimmung des Drehpunkts eines Pendels gesetzt; es sei jedoch angemerkt, dass ein Drehpunkt lediglich einen Sonderfall der Bestimmung des Momentanpols darstellt, auf dessen Bestimmung in Kapitel~\ref{ch:ermittlung_momentanpol} eingegangen wird.
Zunächst wird die Erkennung des Drehpols als vereinfachtes Ziel genommen um herauszufinden, welche Information man durch die Beobachtung eines sich bewegenden Elementes gewinnen kann.

Für die Bestimmung des Endpunktes wird zunächst der Punkt genommen, der am weitesten vom Drehpunkt ist.
Diese Annahme ist für den Anfang hinreichend und wird im Zuge der Zusammensetzung mehrerer Glieder hinfällig, da Gelenke dann zwingend durch die Schnittpunkte entsprechender Glieder definiert sein müssen.

\section{Betrachtung verschiedener Ansätze zur Erkennung von Bewegung} \label{ch:erkennung_von_änderungen}

Um die Bewegung innerhalb einer Bildsequenz zu erkennen werden hier stets zwei Bilder miteinander verglichen, welche zeitlich etwa 16,7 Millisekunden auseinanderliegen.
Die Frequenz von \name{requestAnimationFrame} beträgt im Optimalfall 60 Hertz.
Dieser Optimalfall sei dadurch definiert, dass die \lstinline{step} Funktion aus \lstinline{run} (s. Listing~\ref{lst:gtv_run}) weniger als 16,7 Millisekunden benötigt\footnote{Neben der an \lstinline{run} übergebenen \lstinline{step} Funktion werden natürlich noch andere Funktionen wie \lstinline{model.tick} und \lstinline{updateTimesChart} ausgeführt, diese sollen hier jedoch nicht betrachtet werden. Sie werden daher auch für die Zeitmessung innerhalb von \lstinline{run} ausgeschlossen.}.

\subsection{compareImages}

Da sich in der modellierten Videosequenz nur das Pendel bewegt, reicht es aus die Bilder pixelweise zu vergleichen und die Koordinaten der ungleichen Pixel aufzuzeichnen.
Hierfür wurde eine Funktion \lstinline{stepCompareImages} definiert, welche durch die an die \lstinline{register} Funktion übergebene Funktion aufgerufen wird.

Diese Funktion ruft den aktuellen Inhalt des ersten HTML-Canvas Elementes durch \lstinline{cnv1.getContext('2d').getImageData(0, 0, cnv1.width, cnv1.height).data} auf und speichert diesen.
Dieses Bild soll dann mit vorher gespeichertem Bild verglichen werden.
Da der erste Aufruf dieser Funktion keinen Vergleich mit einem vorangegangen Bild zulässt, wird geprüft ob ein solches existiert und es wird eine Iteration abgewartet bevor der erste Vergleich stattfindet.

Für solche Vergleiche wurde eine Klasse \lstinline{PointCloud} definiert.
Diese Klasse beinhaltet alle Funktionen welche auf und mit Punktwolken in dieser Arbeit benötigt werden.
Unter anderem wird hier eine \lstinline{fromImages} Funktion bereitgestellt, welche zwei Bilder auf Unterschiede untersucht und anhand derer eine Punktwolke zurückgibt.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{fromImages} Funktion, welche eine statische Funktion der \lstinline{PointCloud} Klasse darstellt.}\label{lst:PointCloud}]
fromImages(image1, image2, width, height) {
    const difference = [];

    for (let y = 0; y < height; ++y) {
        for (let x = 0; x < width; ++x) {
            const i = y * width + x;
            if (image1[i * 4] !== image2[i * 4]) {
                difference.push({ x, y });
            };
        }
    }

    return new PointCloud(difference);
}
\end{lstlisting}

Diese Funktion speichert eine \lstinline{difference} Liste, welche jeweils Objekte mit den Koordinaten von gefundenen Unterschieden speichert.

Dieser Ansatz zeichnet sich durch seine Einfachheit aus, hat aber offensichtliche Nachteile.

So würden Änderungen die durch Objekte welche trotz Bewegung auf dem Bild für einen Pixel keine Farbänderung verursachen nicht also solche erkannt werden.
Es werden also nur dort Änderungen erkannt, wo sich die Farbe des entsprechenden Pixels ändert.

Es ist außerdem zu beachten, dass dadurch das die reine Änderung der Pixel betrachtet wird jedes sich bewegende Objekt zwei mal dargestellt wird.
Das liegt daran, dass wenn die beiden Bilder verglichen werden, genau jene Pixel unterschiedlich sind an denen das Pendel im ersten Bild ist und im zweiten nicht mehr ist und genau dort wo das Pendel im zweiten Bild ist und im ersten nicht.
Ohne weitere Analyse lässt sich jedoch nicht so einfach bestimmen in welche Richtung sich das Element bewegt hat.

Außerdem ist mit dieser Methode nicht von einer exakten Abmessung auzugehen, sondern die ermittelten Koordinaten ergeben eher eine Art Punktwolke bei der von einem hohen Maß an Unregelmäßigkeit auszugehen ist.

Es sei an dieser Stelle jedoch lediglich auf diese Nachteile hingewiesen, sodass diese bei Betrachtungen der Ergebnisse berücksichtigt werden können.

An die \lstinline{stepCompareImages} Funktion kann widerrum eine Funktion übergeben werden, welche dann mit dem von \lstinline{fromImages} zurückgegebenen \lstinline{PointCloud} Objekt aufgerufen wird.

Diese Sammlung an Koordinaten wird verwendet um sie auf Regelmäßigkeiten zu untersuchen.
Wie bereits angemerkt, wird als erstes versucht ein Pendel zu rekonstruieren.
Im nachfolgenden sollen für diese Aufgabe unterschiedliche Ansätze untersucht werden.

Die Versuche wurden in unterschiedliche Gruppen unterteilt.
Alle Versuche die mit dem Pendel gemacht werden befinden sich im Verzeichnis \lstinline{src/pendel}.

Die Versuchsgruppe \name{pendel1} beschäftigt sich mit der Untersuchung des kleinsten umfassenden Kreises. % TODO hier anmerken wie man die toll mit der index.html oder so folgen kann.

\subsection{Bestimmung des kleinsten umfassenden Kreises}

Die Koordinaten von Pixeln für die in zwei Bildern ein unterschied gemessen wird, werden in einem Objekt der dafür erstellten \lstinline{PointCloud} Klasse festgehalten.
Diese Koordinaten sollten bei der Drehung eines Gliedes um einen festen Punkt einen Bogen definierbar machen, der Aufschluss über die Position dieses Drehpunktes gibt.

Die genaue Bestimmung eines solchen Bogens durch Mittelpunkt, Radius und eingeschlossenem Winkel anhand der Punktwolke zu ermitteln erscheint zunächst schwierig.
Stattdessen wird beim ersten untersuchten Ansatz der kleinste Kreis bestimmt, welcher alle bisher gesammelten Datenpunkte umfasst.

Den kleinsten umfassenden Kreis zu ermitteln ist ein Problem für das ein Algorithmus existiert welcher in linearer Zeit\footnote{Das heißt die Dauer des Algorithmus steht in linearem Verhältnis zur Menge der Datenpunkte} durchgeführt werden kann.
Der entsprechende Algorithmus wurde von Nimrod Megido~\cite{Megiddo1983} entwickelt und die Implementation wird von \aka{https://github.com/nayuki/Nayuki-web-published-code/blob/master/smallest-enclosing-circle/smallest-enclosing-circle-demo.js} bezogen.
% TODO hier könnte noch etwas vom Algorithmus erzählt werden.
% TODO ein Hinweis auf die Demo von Nayuki ist vielleicht auch noch sinnvoll: https://www.nayuki.io/page/smallest-enclosing-circle


Um einen solchen Kreis zu bestimmen müssen zunächst alle Koordinaten für die eine Änderung erkannt wurde in einer Liste festgehalten werden.

Da zu Beginn der Aufnahme die Region welche durch die Punkte gefüllt wird sehr schnell an Fläche zunimmt, ändern sich die Koordinaten und der Radius des Mittelpunktes des kleinsten umfassenden Kreises relativ schnell.
Sobald sich das drehende Glied einer halben Umdrehung nähert verändert sich die Definition des kleinsten umfassenden Kreises augenscheinlich garnicht mehr und dessen Mittelpunkt scheint mit einer sehr kleinen Abweichung dem tatsächlichen Drehpunkt zu entsprechen.
Entsprechend wird bei diesem Versuch der Drehpunkt als der letzte ermittelte Mittelpunkt des Kreises angenommen.

Das andere Ende des Pendels wird vorerst durch den Punkt definiert dessen Distanz die größte zum prognostizierten Drehpunkt ist.
Dies dient nur zur besseren Visualisierung des erkannten Modells und ist für die eigentliche Aufgabe vorerst irrelevant, da ein Pendel keinen Mechanismus darstellt.

Im ersten Test zeigt sich jedoch, dass die Menge aller erfassten Punkte zu speichern sehr schnell ein Problem in Bezug auf die Performanz wird.
Es ist jedoch nicht notwendig alle Punkte zu behalten.
Für jeden Kreis welcher über den zeitlichen Verlauf gebildet werden können alle Punkte verworfen werden, welche nicht zur Erstellung dieses genutzt wurden.
Dies sind je nach Verteilung der Punktwolke entweder drei oder auch nur zwei Punkte, da ein Kreis sich genau durch mindestens zwei, aber maximal durch bereits drei Punkte bestimmen lässt.

Dafür wurde die Funktion des genutzten Algorithmus angepasst, sodass er nicht mehr nur den Kreis, sondern auch die entsprechenden Koordinaten zurückgibt, welche für die Erstellung des entsprechenden Kreises genutzt wurden\footnote{Die entsprechende Änderung kann auf \aka{https://github.com/klawr/ba/commit/7209dfee5ab0a70470e22862f26f7c45046cd98f} nachvollzogen werden}.
Außerdem wird nach der Ermittlung des Kreises zwischen den bereits bekannten und der aktuell ermittelten Punktwolke unterschieden, sodass die Liste der bekannten Punkte keine Duplikate enthält.

Diese Anpassung reduziert die Menge der Punkte die im ersten Test in einer Sekunde ermittelt werden von 19880 auf 294 Datenpunkte.
Von diesen 294 Datenpunkten sind lediglich 69 den bekannten Datenpunkten zuzuordnen.
Die anderen 225 Punkte lassen sich den gemessenen Veränderungen der letzten beiden verglichenen Bildern zuordnen, was in etwa dem Durchschnitt der Punkte in diesen Tests mit einem Glied dieser Länge entspricht.
Ein weiterer Vorteil ergibt sich noch dadurch, dass Glieder welche sich mehrfach im selben Winkel befinden keine neuen Einträge zu den bekannten Punkten hinzufügen.
Ohne diesen Filter würde die Menge der Datenpunkte linear zunehmen, und die Dauer des Algorithmus, dessen Zeit ebenfalls linear zur Menge der Datenpunkte wächst, entsprechend quadratisch wachsen.

% TODO Vergleich der Performance.

% TODO check das ° Zeichen ob das anständig gedruckt wird. Wird es nicht.
Dieser Ansatz erkennt für ein Glied das sich mindestens 180° um den definierten Punkt dreht ein sehr nahe am tatsächlichen Wert gelegenen Drehpunkt.
Der offensichtliche Nachteil besteht jedoch darin, dass alle Glieder die sich um weit weniger als 180° drehen mit Sicherheit kein gutes Ergebnis liefern, wie im zweiten Test nachvollzogen werden kann.

Nähere Untersuchungen zum kleinsten umfassenden Kreis können jedoch weitere Erkenntnisse bringen.
Zunächst ist der Pfad welcher vom Mittelpunkt des über die Zeit wachsenden kleinsten umfassenden Kreis interessant.
Für die ersten 90° die sich das Glied dreht bewegt sich der Mittelpunkt auf einer Geraden, die exakt Orthogonal zum Drehpunkt steht.
Der Abstand zum Drehpunkt ist ebenfalls bekannt, da bekannt ist dass er exakt dem Radius des zuerst gemessenen kleinsten umfassenden Kreises entspricht\footnote{Das ist Äquivalent zur hälfte der Gliedlänge}.
Die weiterfolgenden 90° durch auf einem Kreisbogen mit dem ersten Mittelpunkt des eben beschriebenen Pfades als Mittelpunkt beschrieben, wobei der Winkel dem des Gliedes entspricht (abzüglich der ersten 90°).
Abschließend landet der Mittelpunkt des kleinsten umfassenden Kreises im Drehpunkt des betrachteten Gliedes.

Es kann außerdem beobachtet werden, dass der kleinste umfassende Kreis, solange er eine Gerade bildet durch drei Punkte definiert wird\footnote{Mit Ausnahme der ersten Iterationen, wo er allein durch die Endpunkte des Gliedes beschrieben werden kann.}.
Sobald das Glied jedoch eine Drehung von über 90° vollführt, wird der Kreis nurnoch durch zwei Punkte beschrieben.
Diese drei Punkte sind die beiden Punkte welche für die erste Iteration\footnote{In der Realität ist es mehr als eine Iteration die der Kreis durch nur zwei Punkte definiert wird, dass kann jedoch auf die Ungenauigkeit der Daten zurückgeführt werden mit denen hier gearbeitet wird.} und dem letzten erfassten Endpunkt des Pendels.
Sobald eine Drehung von über 90° vollführt wurde, ist der Kreis der durch den ersten sowie den letzten Drehpunkt definiert wird jedoch größer, weshalb der Drehpunkt selber nicht mehr zum kleinsten umfassenden Kreis beiträgt.

% TODO Zeige dass das 1. wirklich eine Gerade ist und 2. sie wirklich Orthogonal zum Drehpunkt steht.

Aus diesen Erkenntnissen lässt sich jedoch eine Algorithmus bilden, welcher auch für Bewegungen weit unter 90° eine hinreichend gute Vorhersage über die Position des Drehpunktes bringt.
Hierfür wird, solange die Anzahl der Punkte die den zuletzt gebildeten Kreises bei über zwei liegt, die Steigung vom ersten zum letzten Punkt im Pfad des Mittelpunktes des kleinsten umfassenden Kreises gemessen.
Die Steigung und der y-Achsenabschnitt berechnen sich durch

\begin{equation}
    \begin{split}
        m &= \frac{p2_y - p1_y}{p2_x - p1_x} \\
        b &= p_y - p.x \times m
    \end{split}
    \label{eq:m_steigung}
\end{equation}

wobei hier $p2$ entsprechend der letzte und $p1$ der erste Punkt dieser Liste ist.
Für die Berechnung von $b$ kann für $p$ entweder $p1$ oder $p2$ gewählt werden.

Der Drehpunkt befindet sich nun auf der Orthogonalen zu dieser Gerade mit $p1$ als Schnittpunkt.
Es ist außerdem bekannt, dass der Abstand des Drehpunktes zu $p1$ genau dem Radius des ersten ermittelten kleinsten umfassenden Kreis entsprechen sollte.

Der Abstand in der X-Koordinate des gesuchten Punktes zu $p1$ findet sich durch umstellen des Steigungsdreiecks nach $dx$

\begin{equation}
    \begin{split}
        r^2 &= dx^2 + dx^2 \times m^2 \\
        \frac{r^2}{dx^2} &= 1 + m^2 \\
        dx^2 &= \frac{r^2}{1+m^2} \\
        dx &= \frac{r}{\sqrt{1 + m^2}}
    \end{split}
    \label{eq:steigungsdreieck}
\end{equation}

Wird das $m$ entsprechend durch $\frac{-1}{m}$ getauscht, erhält man den Abstand des gesuchten Punktes von $p_1$ auf der X-Achse.

Um den entsprechenden Wert für die Y-Achse zu finden kann die Berechnung für das $b$ aus Gleichung~\ref{eq:m_steigung} verwendet werden, indem auch dort das $m$ durch $\frac{-1}{m}$ ersetzt wird.
So kann der entsprechende Punkt durch

\begin{equation}
    \begin{split}
        p_{0x} &= p_{1x} - \frac{r}{\sqrt{1 + m^{-2}}} \\
        p_{0y} &= - \frac{p_0x}{m} + p_{1y} + \frac{p_{1x}}{m}
    \end{split}
\end{equation}

gefunden werden.
Es sei darauf hingewiesen, dass $p_{0y}$ sich auch direkt mithilfe von Gleichgung~\ref{eq:steigungsdreieck} berechnen ließe, indem das ursprüngliche $m$ genutzt wird, gemäß des Orthogonaloperators auf diesem Vektor.

Dieser Ansatz basiert auf der Annahme, dass die Steigung die berechnet wird hinreichend genau ist.
Da der kleinste umfassende Kreis mit Sicherheit durch die außenliegensten Punkte definiert wird, ist es jedoch unwahrscheinlich das exakt der Drehpunkt getroffen wird, da der Radius des Drehgelenkes nicht berücksichtigt werden kann.


% TODO Gerade Linie und dann Kreis.
% TODO Abhängigkeit von Bedeckter Fläche
% TODO Ermittlung von Schnittpunkten durch die geraden
% TODO Kathetensatz nach Euklid, welcher über h und q das b ermitteln kann, welches durch den Satz von Thales auf das a schließen kann welches mit q einen Schnittpunkt in B haben muss, wobei B bekanntenmaßen der Drehpunkt ist.
% TODO Das sollte bei steigendem h und q eine immer genauere Prognose von B geben können.

\subsection{Schnittpunkte von Geraden}\label{ch:schnittpunkt_gerade}

Als ein weiterer Ansatz soll nun untersucht werden, ob der Drehpunkt durch die Schnittpunkte von durch die Punktwolke definierten Geraden ermittelt werden kann.
Diese Gerade soll durch die Momentaufnahmen bestimmt werden.

Zunächst soll die Gerade genutzt werden, welche durch die am weitesten voneinander entfernten Punkte der Punktwolke definiert wird.
Diese Gerade sollte in etwa den selben Winkel haben wie der Winkel des tatsächlichen Gelenkes.
Eine Annahme die hierbei implizit getroffen wird, ist dass die Glieder länger sind als sie breit sind, wobei die Länge durch den Abstand der Gelenke definiert ist und die Breite entsprechend durch die Punkte welche normal zu der Längenlinie stehen.

Die am weitest voneinander entfernten Punkte lassen sich durch eine auf der \lstinline{PointCloud} definierten Funktion \lstinline{getMaxDist} finden. % TODO lst:getmaxdist fehlt?
In dieser Funktion wird für jeden Punkt der Punkt gesucht, welcher den größten Abstand zu diesem hat. Es wird außerdem festgehalten welches Paar den größten Abstand hatte.
Mit dieser Funktion wird dann ein Objekt der Klasse \lstinline{Line} zurückgegeben, welches anhand der beiden ermittelten Punkte eine Gerade gemäß der in Gleichung~\ref{eq:m_steigung} gezeigten Formel erstellt..

Eine auf diese Weise definierte Gerade wird dann in einer Liste gespeichert und die nächste Iteration folgt.
Bereits ab der zweiten Iteration können dann die Schnittpunkte dieser Geraden genutzt werden um den Drehpunkt zu bestimmen.

Der Schnittpunkt zweier Geraden ist ebenfalls eine auf der \lstinline{Line} definierten Funktion \lstinline{intersection} definiert.
Der Schnittpunkt zweier Geraden berechnet sich durch
\begin{equation}
    \begin{split}
        p_x &= \frac{b_2 - b_1}{m_1 - m_2} \\
        p_y &= m p_x + b
    \end{split}
    \label{eq:schnittpunkt}
\end{equation}

% TODO Implementation

Wobei für die Berechnung von $p_y$ entweder die Parameter der ersten, oder zweiten Gerade genommen werden können.

\subsubsection{Der Umgang mit Ungenauigkeit}

Für die Verarbeitung der berechneten Punkte wurden zwei weitere Klassen erstellt, welche die Daten verwalten die zur Bestimmung der Pole erforderlich sind.
Die \lstinline{Data} Klasse wird genutzt um einzelne Datenpunkte zu halten, dessen Erwartungswert, Varianz, Standardabweichung und die Gauß'sche Normalverteilung zu berechnen.
Außerdem bietet sie Funktionen zur Vorbereitung der Daten für den \lstinline{g2.chart} Befehl an.

Die zweite Klasse ist die \lstinline{DataXY} Klasse.
Sie bietet die Möglichkeit Punkte direkt zu verwalten.
Punkte sind in diesem Fall definiert als Objekte welche die Eigenschaften \lstinline{x} und \lstinline{y} haben.
Ein \lstinline{DataXY} Objekt hat jeweils die Eigenschaften \lstinline{x} und \lstinline{y} als \lstinline{Data} Objekt und bietet dazu Funktionen an, welche diese gemeinsam auf einem \lstinline{g2.chart} zeichnen können.

In der \lstinline{Data} Klasse ist ein \lstinline{data} Objekt definiert, welches dazu dient die gesammelten Daten zu verwalten.
Statt einer Liste dienen die Schlüssel dieses Objektes als Wert welcher gemessen wurde und der dazugehörige Wert als der Anzahl wie oft dieser gemessen wurde.
Entsprechend wurde eine \lstinline{add} Funktion für die \lstinline{Data} Klasse definiert, welche wie folgt aussieht:

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{add} Funktion welche dazu genutzt wird der \lstinline{Data} Klasse neue Werte hinzuzufügen}\label{lst:data_add}]
add(a) {
if (!a) return;

const r = Math.round(a);
if (Number.isSafeInteger(r)) {
    this.data[r] = this.data[r] ? this.data[r] + 1 : 1;
}
};
\end{lstlisting}

Diese Schreibweise gibt einen besseren Überblick über die Verteilung der Daten.
Außerdem sind weniger Iterationen notwendig um über die Daten zu iterieren.
Das Iterieren über das Objekt wird durch Funktionen wie \lstinline{Objekt.entries} ermöglicht, wie in Listing~\ref{lst:data_mu} gesehen werden kann.

Die Vorhersage eines gesuchten Punktes wird hier stets durch den Erwartungswert aller vorangegangen Messungen bestimmt.

Der Erwartungswert $\mu$ berechnet sich durch

\begin{equation}
    \mu = \frac{1}{n} \sum_{i=1}^n{x_i}
\end{equation}

Die entsprechende Funktion der \lstinline{Data} Klasse ist in Listing~\ref{lst:data_mu} definiert.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{mu} Funktion, welche den Erwartungswert der Daten in \lstinline{Data} berechnet}\label{lst:data_mu}]
get mu() {
    return Object.entries(this.data)
        .reduce((pre, cur) => pre + cur[0] * cur[1], 0)
        / this.length;
}
\end{lstlisting}

Um verschiedene Ansätze miteinander Vergleichen zu können, soll außerdem noch die Standardabweichung berechnet werden.
Die Varianz berechnet sich durch

\begin{equation}
    \sigma^2 = \frac{1}{n - 1} \sum_{i=1}^n(x_i - \mu)^2
\end{equation}

Die entsprechende Implementation ist durch Listing~\ref{lst:data_variance} gegeben.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{variance} Funktion, welche die Varianz der Daten in \lstinline{Data} berechnet}\label{lst:data_variance}]
get variance() {
    const mu = this.mu;

    return Object.entries(this.data)
        .reduce((pre, cur) =>
            pre + (((+cur[0] - mu) ** 2) * (+cur[1])), 0)
        / (this.length - 1);
}
\end{lstlisting}

\lstinline{mu} wird hier zwischengespeichert, damit dieser nicht für jede Iteration innerhalb des \lstinline{reduce} aufrufes erneut ausgerechnet werden muss.

Die Standardabweichung $\sigma$ ist entspechend die Quadratwurzel der Varianz.

Um die entsprechenden Ergebnisse mit der Gauß'schen Normalverteilung zu Vergleichen wurde eine Funktion geschrieben, welche vom \lstinline{g2.chart} genutzt werden kann um diese neben die gesammelten Daten zu zeichnen.

Die Funktion für die Gauß'sche Normalverteilung berechnet sich durch

\begin{equation}
    f(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}
\end{equation}

Die entsprechende Implementation ist gegeben durch Listing~\ref{lst:data_gauss}.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{gaussianDistribution} Funktion, welche die Normalverteilung für die gegebene Varianz und den Erwartungswert formt.}\label{lst:data_gauss}]
gaussianDistribution(x) {
    const mu = this.mu;
    const variance = this.variance;
    const nominator = Math.exp(-((x - mu) ** 2) / (2 * variance));
    const denominator = Math.sqrt(2 * Math.PI * variance);
    return nominator / denominator;
}
\end{lstlisting}

Diese Funktion kann dann vom \lstinline{g2.chart} aufgerufen werden um den entsprechenden Graphen zu zeichnen.
Die Implementation eines solchen Aufrufs wird in Listing~\ref{lst:data_getChart} gezeigt.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{getChart} Funktion der \lstinline{Data} Klasse.}\label{lst:data_getChart}]
getChart(limit) {
    const gtv = globalTestVariables;
    const data = this.alignForChart(limit);
    const fn = (i) => this.gaussianDistribution(i);

    return g2().clr().view({ cartesian: true }).chart({
        x: 20, y: 20, b: 280, h: 150,
        funcs: [{ data }, { fn, dx: 1 },],
        xaxis: {}, yaxis: {},
    });
};
\end{lstlisting}

Die \lstinline{alignForChart} Funktion sorgt für die korrekte Formatierung des \lstinline{data} Objektes um durch \lstinline{g2.chart} dargestellt werden zu können.

\subsubsection{Nutzung des Schwerpunktes mehrerer Datenpunkte}\label{ch:nutzung_des_schwerpunktes}

Idealerweise sollten alle Schnittpunkte der berechneten Geraden die selben Koordinaten haben.
Wäre dies der Fall, dann wäre die Varianz gleich null und bereits nach zwei Iterationen hätte man ein ideales Ergebnis.
Da dies jedoch nicht der Fall ist, wird für jede neue Gerade jeder Schnittpunkt mit den vorangegangen Geraden dem \lstinline{Data} Objekt übergeben.

Diese Methode liefert schnell einen Erwartungswert der nah an dem tatsächlichen Wert auch für Schwungwinkel weit unter 180°.

Nachteilig erscheint es, dass der Winkel durch die am weitesten voneinander entfernten Punkte sehr stark variiert, da wie in Abschnitt~\ref{ch:erkennung_von_änderungen} bereits erwähnt, bei dem Vergleich zweier zeitlich aufeinander folgenden Bilder sowohl die Position des ersten, als auch die Position des Pendels im zweiten Bild enthalten ist.
Um dieses Problem zu Umgehen sollen nun mehrere am weitesten auseinander liegenden Punkte ermittelt werden und die Prozedur mit diesen wiederholt werden.

Es zeigt sich, dass die Standardabweichung für die selbe Menge an Iterationen bei der Nutzung des Schwerpunktes der 5 am weitesten auseinanderliegenden Punkte sich leicht reduziert.

% TODO hier sollte ein Bild vorher zu nachher eingefügt werden um diese Aussage zu untermauern.

\subsection{Bestimmung der Regressionsgeraden}\label{ch:bestimmung_regressionsgerade}

Die Gerade welche den geringsten Fehler gegenüber einer Menge an Punkten darstellt wird als Regressionsgerade bezeichnet.

Die Berechnung der Regressionsgeraden nach der Gauß'schen Methode der kleinsten Quadrate wird durch % Zitat Papula 3 S. 696

\begin{equation}
    \begin{split}
        \bar{x} &= \sum_{i=1}^n x_i, \quad \bar{y} = \sum_{i=1}^n y_i \\
        m &= \left(\sum_{i=1}^n (x_i y_i) - n \bar{x} \bar{y}\right) \left(\sum_{i=1}^n x_i^2 - n \bar{x}\right)^{-1} \\
        b &= \bar{y} - m\bar{x}
    \end{split}
    \label{eq:regression_gauss}
\end{equation}

unterstellt jedoch einen vernachlässigbar kleinen Fehler auf der X-Achse.
Dies resultiert in einer falschen Regressionsgerade wenn sie vertikal sein sollte.

Diese Regressionsgerade hat jedoch ein anderes Problem aufgezeigt.
Wenn zwei Bilder die eine Drehung darstellen miteinander verglichen werden, indem jene Pixel behalten werden in denen eine Änderung zu erkennen ist, dann werden typischerweise mehr Änderungen erkannt, je weiter man sich radial von Drehpunkt entfernt.
Diese Beobachtung ist nicht überraschend, denn die absolute Geschwindigkeit eines Punktes nimmt mit Abstand zum Drehpunkt zu.
Diese tatsache sorgt jedoch dafür, dass je weiter Regionen vom Drehpunkt entfernt sind, umso größer wird ihr Einfluss auf die Regressionsgerade.
Hier kann jedoch eine Funktion abhilfe schaffen, die auch in der Bilderkennung durch neurale Netzwerke genutzt wird.
Diese als Non-Max Suppression % TODO Cite...
bezeichnete Funktion wird eigentlich dafür genutzt, dass durch Bilderkennung klassifizierte Objekte auf Bildern direkt nebeneinander liegen gefiltert werden für das Bild, dass den höchsten Konfidenzwert besitzt.
Da den Pixeln hier kein Konfidenzwert zugeordnet werden kann, kann allerdings eine Funktion genutzt werden welche durch diesen Ansatz inspiriert die Dichte der Punkte filtert.
Dadurch wird die Dichte der erkannten Pixel quasi homogen und der Drehpunkt liegt etwas näher an dem tatsächlich erkannten, ohne viel Präzision bei der Bestimmung der Steigung in Kauf zu nehmen.

Hierfür wurde der \lstinline{PointCloud} Klasse die \lstinline{removeOverlaps} Funktion definiert, welche für ein \lstinline{PointCloud} Objekt ein neues gefiltertes Objekt zurückgibt.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{removeOverlaps} Funktion der \lstinline{PointCloud} Klasse.}\label{lst:pointcloud_removeOverlaps}]
removeOverlaps(dist = 5) {
    let copy = [...this.points];
    const survivor = [];
    while (copy.length) {
        const pt = copy.pop();
        survivor.push(pt);
        copy = copy.filter(
            (rec) =>
                Math.abs(rec.x - pt.x) >= dist ||
                Math.abs(rec.y - pt.y) >= dist
        );
    }
    return new PointCloud(survivor);
};
\end{lstlisting}

Um jedoch die Regressionsgerade an sich zu korrigieren wird auf eine andere Methode zur Ermittlung der am besten passenden Gerade zurückgegriffen.

\subsubsection{Orthogonale Regression}\label{ch:orthogonale_regression}

Während die vorher angesprochene Regressionsgerade den Abstand der Punkte in Y-Richtung zu minimieren versucht, ist der nachfolgende Ansatz dazu gedacht den Fehler der Punkte orthogonal zur gesuchten Gerade zu minimieren~\cite{JuergenHedderich2020}.% TODO[S. 140]

\begin{equation}
    \begin{split}
        m &= \frac{\sigma_y^2 - \sigma_x^2 + \sqrt{(\sigma_y^2 - \sigma_x^2)^2 + 4\sigma_{xy}^2}}{2\sigma_{xy}} \\
        b &= \bar{y} - m \bar{x}
    \end{split}
    \label{eq:orthogonal_regression}
\end{equation}

Diese Gleichung nutzt die Varianz der einzelnen Datensammlungen um damit die entsprechende Steigung der Geraden zu ermitteln.
Unter der Berücksichtigung, dass diese bereits Implementationen haben, welche in Listing~\ref{lst:data_variance} nachgesehen werden können, muss hierfür also nurnoch die Ermittlung der Kovarianz $\sigma_{xy}^2$ implementiert werden.
Diese kann passend der \lstinline{DataXY} Klasse hinzugefügt werden, welche für die Tests die entsprechenden Punkte bereithält.

\begin{lstlisting}[language=JavaScript, caption={Implementation der \lstinline{covariance} Funktion in der \lstinline{DataXY} Klasse}.\label{lst:dataxy_covariance}]
get() covariance() {
    const xmu = this.x.mu;
    const ymu = this.y.mu;

    return this.pts.reduce((pre, cur) =>
        pre + (cur.x - xmu)(cur.y - ymu), 0)
        / (this.pts.length - 1);
}
\end{lstlisting}

Hier werden die entsprechenden Erwartungswerte analog zu Listing~\ref{lst:data_variance} festgehalten, damit diese nicht öfters ermittelt werden müssen.

Die erzeugung der Regressionsgerade kann dann auf der \lstinline{List} Klasse defniert werden.
Die Implementation kann in Listing~\ref{lst:line_fromRegressionLine} nachvollzogen werden.

\begin{lstlisting}[language=JavaScript, caption={Erstellung von \lstinline{Line} Objekten durch die orthogonale Regressionsgerade für Datenpunkte} \label{lst:line_fromRegressionLine}]
static fromRegressionLine(pts, g) {
    const data = new DataXY(pts);

    const sy = data.y.variance;
    const sx = data.x.variance;
    const sxy = data.covariance;

    const m = (sy - sx + Math.sqrt((sy - sx) ** 2 + 4 * sxy**2)) 
        / (2 * sxy);
    const b = data.y.mu - m * data.x.mu;

    return new Line({m, b});
}
\end{lstlisting}

\subsection{Vergleich des Verlaufes von Randpunkten}

Die letzte Versuchsreihe die gemacht werden soll ist der Abgleich zweier durch die Punktwolke entstandener Pfade von Punkten.
Die ausgewählten Punkte bestehen jeweils aus dem Punktepaar mit größter Distanz pro Abgleich.
Hierfür wird zur Ermittlung zunächst die selbe Methodik verwendet wie in Kapitel~\ref{ch:schnittpunkt_gerade}.

Allerdings muss hier sichergestellt werden, dass jeweils der korrekte Nachfolger für einen Pfad der dazu gehörigen Liste hinzugefügt wird.
Der bisherige Ansatz beinhaltet keine Information über die zugehörigkeit von einzelnen Punkten in aufeinander folgenden Bildabgleichen.
Um den Verlauf von solchen Messdaten über Zeit nutzbar zu machen wurde die \lstinline{Groups} Klasse erstellt.
Bei diesem Abgleich von Randpunkten ist diese lediglich für die zuordnung dieser in die entsprechenden Messungen der letzten Iterationen verantwortlich.
Entsprechend wird bei jeder Iteration der Abstand des Punktpaares mit dem letzten Eintrag der entsprechenden Listen verglichen und können so entsprechend zugeordnet werden.

Um mit dieser Information den Drehpunkt des Pendels zu ermitteln reicht es dann aus die Länge des gesamten Pfades zu messen, da der gesamtweg des Mittelpunktes erheblich kürzer sein sollte, als der des Enpunktes.
Diese Beobachtung hält jedoch dem Test nicht zwingend statt.
Das liegt vorallem darin, dass die in Kapitel~\ref{ch:bestimmung_regressionsgerade} gemacht Beobachtung, dass je weiter der Abgleich zweier Bilder vom tatsächlichen Drehpunkt entfernt ist die absolute Geschwindigkeit höher und die Dichte der Punktwolke entsprechend in solchen Regionen höher ist.
Das hat zur Folge das die Fluktuationen erheblich zur Länge des Pfades der Bewegung des ermittelten Mittelpunktes beiträgt.

Wird dieser Umstand versucht mit dem Schwerpunkt der Endpunkte zu behandeln, wie es in Kapitel~\ref{ch:nutzung_des_schwerpunktes}, scheint es diesen Umstand jedoch erheblich schlimmer zu machen.
Beheben lässt sich dieser indem der kleinte umfassende Kreis um die beiden gesammelten Gruppen gebildet wird und derjeniger mit dem kleinerem Radius den Mittelpunkt darstellt.

\subsection{Auswertung der Beobachtungen}

Die hier besprochenen Ansätze haben viele Erkenntnisse eingebracht welche Information aus dem Abgleich zweier Bilder gewonnen werden kann.
Es wurden für die Struktur der Versuche vier Klassen erstellt welche sicherlich auch bei weiteren Versuchen helfen werden.
Als besonders wichtig hat sich die statistische Analyse der Beobachtungen gezeigt.
Der Erwartungswert ist der intuitive Ansatz für die Ermittlung der Koordinaten gesuchter Punkte.
Die Standardabweichung ermöglicht es die unterschiedlichen Ansätze qualitativ zu vergleichen.

Im Nachfolgenden soll noch eine weitere Möglichtkeit untersucht werden nutzbare Information aus Veränderungen in Bildern zu ermitteln.
