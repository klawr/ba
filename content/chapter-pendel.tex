\chapter{Rekonstruktion eines Pendels}

Statt der vollständigen Rekonstruktion eines Mechansimus, soll zunächst mit einem einfachen Pendel begonnen werden.
Dieses stellt im Grunde ein einzelnes Glied eines beliebigen Mechanismus dar.
Die korrekte Erkennung eines Pendels ist also eine notwendige Bedingung für einen Ansatz der die Glieder des Mechanismus einzeln betrachtet\footnote{Das gilt im Grunde für alle Mechanismen welche rotierende Elemente beinhalten. Für alle Glieder welche keine Absolutpole besitzen sei die Relativbewegung gegenüber solchen heranziehbar}.

Als zentrales Ziel dieses Kapitels wird die korrekte Bestimmung des Drehpunkts eines Pendels gesetzt; es sei jedoch angemerkt, dass ein Drehpunkt lediglich einen Sonderfall der Bestimmung des Momentanpols darstellt, auf dessen Bestimmung in % TODO
näher eingegangen wird.
Zunächst wird die Erkennung des Drehpols als vereinfachtes Ziel genommen um herauszufinden, welche Information man durch die Beobachtung eines sich bewegenden Elementes gewinnen kann.

Für die Bestimmung des Endpunktes wird zunächst der Punkt genommen, der am weitesten vom Drehpunkt ist.
Diese Annahme ist für den Anfang hinreichend und wird im Zuge der Zusammensetzung mehrerer Glieder hinfällig. % TODO wieso? ja weil man dann die Schnittpunkt der Glieder, bzw. die Relativpole nimmt. Aber das soll erstmal geschrieben werden bevor ich hier schon rumposaune dass das geht.

\section{Erstellung der Tests}

\subsection{Die index.html}

Die Testseiten sind jeweils eigenständige HTML-Seiten welche über das HTML-Iframe Element in einer zentralen Testseite nebeneinander untersucht werden können.
Die Tests sind widerrum gruppiert in einzelne zu untersuchende Fragmente.
Für diese Gruppierung wurde in der \name{index.html} ein \lstinline{tests} Objekt definiert welches Information über die entsprechenden Gruppen bereithält.

Dieses Testobjekt wird in Listing~\ref{lst:tests_objekt}

\begin{lstlisting}[language=JavaScript, caption={Definition des \lstinline{tests} Objekts in der \name{index.html} mit etwas gekürztem \lstinline{title}.}\label{lst:tests_objekt}]
const tests = {
    pendel: {
        title: "Tests zum Finden des Drehpunkts...",
        indices: [5, 5, 2]
    },
    momentanpol: {
        title: "Tests zur Ermittlung des Momentanpols...",
        indices: [3, 2]
},
    gruppe: {
        title: "Tests zum Segmentieren der Datenpunkte ...",
        indices: [2, 1, 1, 3]
    },
}
\end{lstlisting}

In diesem \lstinline{tests} Objekt ist die festgehalten, welche Gruppen es gibt, wie diese betitelt werden und die \lstinline{indices} Eigenschaft der einzelnen Eigenschaften bezeichnen wie viele Tests diese Gruppe jeweils bereitstellt.

Für diese \lstinline{indices} ist die Ordnerstruktur des Projektes von Bedeutung.
Jede Eigenschaft des \lstinline{tests} Objekts hat im \name{src} Ordner relativ zum Root-Verzeichnis einen entsprechenden Ordner.
Dieser enthält die einzelnen HTML-Testseiten welche ebenfalls nach einem festen Schema benannt sind.
So ist der relative Pfad zum Root-Verzeichnis eines Tests \name{src/[Gruppe]/[Gruppe][Index1]\_[Index2].html}.
Der erste Test ist also unter dem Relativpfad \name{src/pendel/pendel1\_1.html} zu finden.

Dieser zunächst komplex wirkende Aufbau erlaubt es allerdings alle Tests durch Listing~\ref{lst:tests_objekt_reason} in die \name{index.html} einbauen.

\begin{lstlisting}[language=JavaScript, caption={Iteration über das tests Objekt zur Population der index.html.}\label{lst:tests_objekt_reason}]
Object.entries(tests).forEach((kv, i) => {
    const title = document.createElement('h2');
    title.innerHTML = kv[1].title;
    const summary = document.createElement('summary');
    const details = document.createElement('details');

    kv[1].indices.forEach((e, j) => {
        const innerSummary = document.createElement('summary');
        const innerDetails = document.createElement('details');
        innerSummary.innerHTML = `${kv[0] + (j + 1)}`;
        innerDetails.appendChild(innerSummary);
        details.appendChild(innerDetails);

        for (let m = 1; m <= e; ++m) {
            const iframe = document.createElement('iframe');
            iframe.src = `src/${kv[0]}/${kv[0]+(j + 1)}_${m}.html`;
            innerDetails.appendChild(iframe);
        }
    });
    summary.innerHTML = kv[1].title;
    details.appendChild(summary);
    document.body.appendChild(details);
});
\end{lstlisting}

Hier wird für jeden Eintrag im \lstinline{tests} Objekt ein neues HTML-Details Element erstellt. % TODO MDN link?
Über die \lstinline{indices} Eigenschaft der einzelnen Einträge wird dann iteriert um die einzelnen Gruppen gemeinsam in ein weiteres HTML-Details Element zu platzieren.
Über den Wert der einzelnen Elemente der \lstinline{indices} Liste wird dann festgestellt wie viele HTML-Iframe Elemente erstellt werden sollen und welchen Pfad diese als Quelle (\lstinline{src}) nehmen sollen.

Damit die Seite eine anständige Formatierung besitzt wurden die entsprechenden Elemente durch CSS gestaltet, worauf hier jedoch nicht weiter eingegangen werden soll.

\subsection{simulation.js}

Die Anforderungen an die Tests ist grundlegend gleich.
Aus dem Grund hat sich schnell gezeigt, dass es sinnvoll ist den meisten Code in einer zentralen Datei abzulegen, welche großteils von jedem Test genutzt werden soll.
Aus diesem Grund referenziert jede der einzelnen HTML-Seiten die \name{simulation.js} Datei.

Hier wird das \lstinline{globalTestVariables} Objekt definiert.
Dieses Objekt soll dazu dienen die genutzten globalen Variablen zu begrenzen.
Es beinhaltet alle Referenzen zu den HTML-Elementen auf welche im Zuge der Tests zugegriffen werden könnten, sowie den Referenzen zu den einzelnen \name{CanvasRenderingContext2D} Objekten welche von \name{g2} genutzt werden um auf die entsprechenden HTML-Canvas Elemente zu zeichnen.
Außerdem werden globale Konstanten wie unter Anderem die Höhe und Breite der HTML-Canvas Elemente hier zentral bestimmt.

Des Weiteren werden im \lstinline{globalTestVariables} Objekt mehrere Funktionen definiert, welche von allen Tests geteilt werden.
Auf diese Funktionen soll im nachfolgenden noch etwas eingegangen werden um zu verstehen wie sich die Testseiten zusammensetzen.
Alle nachfolgenden Funktionen sind als Eigenschaften des \lstinline{globalTestVariables} Objektes zu verstehen.

\subsubsection{createElements}

Die HTML-Elemente welche innerhalb der Testseiten verwendet werden sind grundsätzlich stets die gleichen.
Aus dem Grund beschreibt die \lstinline{createElements} Funktion die Befüllung der Testseiten mit den entsprechenden HTML-Elementen.
So muss bei entsprechendem Wunsch zur Änderung nur an dieser zentralen Stelle beispielsweise der Inhalt eines Knopfes geändert werden.
Außerdem werden in dieser Funktion die entsprechenden Eigenschaften der \lstinline{globalTestVariables} auf die HTML-Elemente und \name{CanvasRenderingContext2D} gesetzt.

\subsubsection{run}

Die \lstinline{run} Funktion trägt sorge dafür, dass alle Tests unter den selben Konditionen aufgerufen werden.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{globalTestVariables.run} Funktion.}\label{lst:gtv_run}]
run(step) {
    this.g.exe(this.ctx1);
    this.model?.tick(1 / 60);
    step();
    this.updateTimesChart().exe(this.ctx_times);

    if (this.running) {
        this.rafId = requestAnimationFrame(() => {
            this.time_reset = performance.now();
            this.run(step)
        });
    }
},
\end{lstlisting}

Sollte ein \name{mec2} Modell definiert sein, dann soll dieses an dieser Stelle seine \lstinline{tick} Funktion anwenden, damit es um einen Zeitschritt weiter iteriert wird.
Es wird an dieser Stelle davon ausgegangen, dass wenn ein \name{mec2} Modell definiert ist, dieses zur Animation verwendet werden soll.
Innerhalb der Testfunktionen soll dieses jedoch nicht modifiziert werden.

Anschließend wird der \name{CanvasRenderingContext2D} des ersten der vier HTML-Canavs Elemente \lstinline{ctx1} beschrieben.
Dieser sollte ausschließlich hier beschrieben werden, damit der Test nicht versehentlich Einfluss auf die Zeichnung nimmt.
Es soll eine grundlegende Prämisse sein, dass die gesuchte Funktion zur Bestimmung des Mechanismus ausschließlich Anhand der Bildsequenzen funktionieren soll und selbst keinen Einfluss auf diese hat.
Das soll hierdurch sichergestellt werden.

Nachdem der HTML-Canvas gerendert wurde, wird eine an \lstinline{run} übergebene Funktion ausgeführt.
Diese Funktion ist durch den Test selber definiert und führt alle Vergleiche und Berechnungen aus welche durchgeführt werden sollen.
Über diese Funktionen wird anschließend in den einzelnen Tests geschrieben.

Abschließend wird hier noch die Zeit welche seit dem letzten \lstinline{run} Aufruf verstrichen ist aufgezeichnet, indem \lstinline{updateTimesChart} aufgerufen wird.
In \lstinline{updateTimesChart} wird der aktuelle Zeitpunkt mittels \lstinline{performance.now()} % TODO MDN Link oder besser erklären.
ermittelt und in einer Liste hinzugefügt welche die Historie der Geschwindigkeiten der einzelnen \lstinline{run} festhält.
Es wird außerdem gemessen wie viel Zeit seit dem Beginn der Aufzeichnung vergangen ist.
Dieser Graph wird anschließend auf dem vierten HTML-Canvas Element durch den \lstinline{exe(ctx_times)} Aufruf gezeichnet.

Nachdem anschließend geprüft wurde ob der Test weiter laufen soll \footnote{\lstinline{running} kann beispielsweise durch einen Start/Stop Knopf umgeschaltet werden.} wird die Zeit für die nächste Runde erneut auf den aktuellen Zeitpunkt gesetzt um die Zeit die es gedauert hat um den Graphen zu zeichnen auszuschließen und die \lstinline{run} Funktion wird erneut durch \lstinline{requestAnimationFrame} aufgerufen.

\subsubsection{register}

\lstinline{register} ist die Funktion, welche von den einzelnen Tests aufgerufen wird um die HTML-Seite zu befüllen und den Test zu injizieren.

Hier wird zunächst der Titel festgelegt, welcher dem Namen der HTML-Datei entspricht.
Dieser Titel wird in ein HTML-Anker % MDN Link platziert,
platziert, so dass diese einfacher in der \name{index.html} unterschieden werden können.
Es dient außerdem als Hyperlink, der genutzt werden kann um isoliert auf den Test zuzugreifen, wenn man sich auf der \name{index.html} befindet.

An dieser Stelle wird außerdem ein Knopf erzeugt, welcher das Laden des Tests ermöglicht und \lstinline{createElement} ausführt.
Sollte ein \name{mec2} Modell definiert sein, so wird hier die \lstinline{mec.model.extend} Funktion mit diesem aufgerufen und dann dessen \lstinline{init} Funktion bemüht um dieses zu instanzieren. % TODO mec2 Link?

Wenn der Test geladen wird, wird die Simulation vorbereitet und es wird einmalig die \lstinline{run} Funktion aufgerufen um das erste Bild zu zeigen\footnote{Da \lstinline{globalTestVariables.running} initial \lstinline{false} ruft die \lstinline{run} Funktion kein \lstinline{requestAnimationFrame} auf.}.

Hier wird außerdem noch der Knopf zum Starten und Pausieren des Tests definiert.
Die Betätigung dieses Knopfes resultiert in einem Umschalten der \lstinline{globalTestVariables.running} Variable und dem Ausführen von \lstinline{run}.

Eine vollständige Betrachtung des \lstinline{globalTestVariables} Objektes kann unter % TODO Link
nachgesehen werden.

% TODO irgendwo erklären wieso diese one-definition rule sinnvoll ist. Besser noch die odr selber erklären.

\subsection{Aufbau der Testseiten}

Die HTML-Seiten wurden einheitlich gestaltet, sodass an diesen nicht viel geändert werden muss um weitere Tests zu definieren.

Für die Visualisierung der Versuche wurden Funktionen definiert, welche eine HTML-Seite erstellt welches für alle Versuche eine einheitliche Oberfläche erstellt.
Diese HTML-Seite enthält jeweils einen Text, der kurz beschreibt was in dem entsprechenden Versuch untersucht wird und vier HTML-Canvas Elemente, mit einer jeweiligen Breite von 320 Pixeln, sowie einer Höhe von 180 Pixeln.

Das erste dieser HTML-Canvas Elemente enthält eine Abbildung des \name{mec2} Modells.
Dieses HTML-Canvas Element wird dazu verwendet den getesteten Algorithmus mit Bildern zu versorgen mit denen dieser dann den entsprechenden Mechanismus rekonstruieren soll.

Das zweite HTML-Canvas Element soll genutzt werden um zu visualisieren wie dieser Ansatz funktioniert.
Diese Visualisierung soll dazu dienen einen besseren Eindruck davon zu bekommen ob die darunterliegenden Funktionen funktionieren und ob Erkenntnisse daraus gezogen werden können.

Das dritte HTML-Canvas Element dient zur Auswertung der ermittelten Daten.
In den meisten Tests wird dieses Element dazu genutzt um die ermittelten Koordinaten in einem Graphen darzustellen und diesen dann nach weiteren Erkenntnissen zu untersuchen.

Um die Performanz der einzelnen Tests zu untersuchen wird zwischen den Iterationen die Zeit gemessen.
Diese wird dann im vierten HTML-Canvas Element aufgezeichnet.
In manchen Fällen hat es sich als sehr sinnvoll erwiesen früh zu erkennen ob einzelne Funktionen eine ungewöhnlich lange Zeit für die Iterationen benötigen.

\subsection{Registrierung und Simulation der Tests}

Im ersten der vier HTML-Canvas Elemente wird eine Bildsequenz gezeigt, welche durch eine Funktion untersucht werden soll.
Diese Untersuchung sollte in keinem Fall einfluss auf die Bildsequenz haben, da das gesuchte Verfahren im Endeffekt unabhängig von der Quelle funktionieren soll.

\subsection{Definition eines \name{mec2} Modells}

Ein Pendel wird mithilfe von \name{mec2} definiert.
Dieses soll in den nachfolgenden Tests dann von verschiedenen Höhen aus geschwungen werden. % TODO geschwungen wird?
Das Pendel wird lediglich durch den Drehpunkt, den Endpunkt und dessen konstante Länge zueinander definiert.
Der Endpunkt ist im nachfolgendem der einzige Punkt mit einem Gewicht, da durch die Annahme von geschwichtslosen Gliedern diese keinen Einfluss haben.
Auf einen Antrieb wurde in den Tests zunächst verzichtet, weil dieser für die Erkennung der Bewegung nicht notwendig ist.
Ein Beispiel für die Definition eines Pendelmodells für \name{mec2} wird in Listing~\ref{lst:pendel} gezeigt.

\begin{lstlisting}[language=JavaScript, caption={Definition eines einfachen Pendels in \name{mec2}, inklusive animation.}\label{lst:pendel}]
const model = {
    id: 'pendulum',
    gravity: true,
    nodes: [
        { id: 'A0', x: 150, y: 120, base: true },
        { id: 'A1', x: 230, y: 150 }
    ],
    constraints: [
        { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
    ]
};
\end{lstlisting}

Das Pendel besteht entsprechend aus zwei \lstinline{nodes}, welche die Gelenkpunkte darstellen.
Eine dieser beiden Gelenkpunkte wird als \lstinline{base} deklariert, was bedeutet sie ist unbeweglich und damit stellt sie den Punkt dar um welchen das Pendel schwingt.

% TODO subsection simulation auf die Simulation eingehen.

% Um das Pendel entsprechend zu animieren wird der Programmcode genutzt der auf der Dokumentationsseite \aka{https://goessner.github.io/mec2/microjam.md/getting_started.html} hinterlegt ist genutzt, worauf jedoch in 

\section{Erkennung von Änderungen}\label{ch:erkennung_von_änderungen}

Um die Bewegung innerhalb einer Bildsequenz zu erkennen werden zunächst zwei Bilder miteinander verglichen, welche zeitlich etwa 16,7 Millisekunden auseinanderliegen.
Die Frequenz von \name{requestAnimationFrame} beträgt im Optimalfall\footnote{Das bedeutet das keine Berechnungen länger als 16,7 Millisekunden benötigen, welche die Animation entsprechend verlangsamen würde.} 60 Hertz.

Da sich in der modellierten Videosequenz nur das Pendel bewegt, reicht es aus die Bilder pixelweise zu vergleichen und die Koordinaten der ungleichen Pixel aufzuzeichnen.
Hierfür wurde die \lstinline{simulate} Function, welche in Listing~\ref{lst:pendel} gezeigt wurde mit dem Programmcode aus Listing~\ref{lst:simulate_compare_images} versehen.

\begin{lstlisting}[language=JavaScript, caption={TODO caption....}\label{lst:simulate_compare_images}]
const simulate = () => {
    model.tick(1 / 60); // solve model with fixed stepping
    g.exe(ctx1);        // render its pose on the canvas

    const image1 = ctx1.getImageData(
        0, 0, cnv1.width, cnv1.height).data;

    window.setTimeout(() => {
        const image2 = ctx1.getImageData(
            0, 0, cnv1.width, cnv1.height).data;
        const result = compare_images(
            image1, image2, cnv1.width, cnv1.height);
    }

    g2().clr().exe(ctx2);
    for (let i = 0; i < result.length; ++i) {
        const zone = result[i];

        g2().clr().cir({x: zone.x, y: zone.y, r: 1}).exe(ctx2);
    }
};
\end{lstlisting}

Wobei \lstinline{ctx1} und \lstinline{ctx2} den \lstinline{RenderingContext} des jeweiligen HTML-Canvas Elementes repräsentieren.
\lstinline{compareImages} wird in Listing~\ref{lst:compareImages} gezeigt.

\begin{lstlisting}[language=JavaScript, caption={Definition der \lstinline{compareImages} Function}\label{lst:compareImages}]
function compareImages(image1, image2, width, height) {
const difference = [];

for (let y = 0; y < height; ++y) {
    for (let x = 0; x < width; ++x) {
        const i = y * width + x;
        if (image1[i * 4] !== image2[i * 4]) {
            difference.push({x, y});
        };
    }
}

return difference;
}
\end{lstlisting}

Eine Momentaufnahme dieser Konstruktion kann in Abbildung~\ref{fig:compareImages} gesehen werden.

\begin{figure}[htb]
    \includegraphics[width=\textwidth]{gfx/compare_images_1.png}
    \caption{Darstellung des Pendels und die dazugehörige erkannte Änderung innerhalb des Bildes.}
    \label{fig:compareImages}
\end{figure}

Zu beachten ist, dass das Pendel zwei mal gezeigt wird.
Das liegt daran, dass wenn die beiden Bilder verglichen werden, genau jene Pixel unterschiedlich sind an denen das Pendel im ersten Bild ist und im zweiten nicht mehr ist und genau dort wo das Pendel im zweiten Bild ist und im ersten nicht.
Ohne weitere Analyse lässt sich jedoch nicht so einfach bestimmen in welche Richtung sich das Pendel bewegt.
Für die anschließende Untersuchung kann das jedoch ignoriert werden, allerdings ist es wichtig solche Besonderheiten zu betrachten um mögliche Fehlerquellen schneller zu finden.


Insgesamt wurden drei verschiedene Ansätze untersucht, welche im Folgenden betrachtet werden sollen.

\section{Betrachtung unterschiedlicher Ansätze}

\subsection{Bestimmung des kleinsten umfassenden Kreises}

Wie bereits vorher angemerkt, werden die Koordinaten aller Pixel aufgezeichnet für die bei einer Bewegung eine Änderung bemerkt wurde.
Diese Pixel sollten bei der Drehung eines Gliedes um einen festen Punkt einen Bogen definieren, der Aufschluss über die Position dieses Drehpunktes gibt.

Die genaue Bestimmung eines solchen Bogens anhand der Punktwolke zu ermitteln erscheint kein Problem zu sein für welches eine offensichtliche Lösung existiert.
Stattdessen wird beim ersten untersuchten Ansatz dieser Thesis der kleinste Kreis bestimmt, welcher alle gesammelten Datenpunkte umfasst.
Diesen Kreis zu ermitteln ist ein Problem für das ein Algorithmus existiert welcher in linearer Zeit\footnote{Das heißt die Dauer des Algorithmus steht in linearem Verhältnis zur Menge der Datenpunkte} durchgeführt werden kann.
Der entsprechende Algorithmus wurde von Nimrod Megido~\cite[Megiddo1983] entwickelt und die Implementation wird von \aka{https://github.com/nayuki/Nayuki-web-published-code/blob/master/smallest-enclosing-circle/smallest-enclosing-circle-demo.js} bezogen.
% TODO hier könnte noch etwas vom Algorithmus erzählt werden.
% TODO ein Hinweis auf die Demo von Nayuki ist vielleicht auch noch sinnvoll: https://www.nayuki.io/page/smallest-enclosing-circle


Um einen solchen Kreis zu bestimmen müssen zunächst alle Koordinaten für die eine Änderung erkannt wurde in einer Liste festgehalten werden.

Da zu Beginn der Aufnahme die Region welche durch die Punkte gefüllt wird sehr schnell an Fläche zunimmt, ändern sich die Koordinaten und der Radius des Mittelpunktes des kleinsten umfassenden Kreises.
Sobald sich das drehende Glied einer halben Umdrehung nähert verändert sich die Definition des kleinsten umfassenden Kreises augenscheinlich garnicht mehr und dessen Mittelpunkt scheint mit einer sehr kleinen Abweichung dem tatsächlichen Drehpunkt zu entsprechen.

% TODO Abändern auf Standard-Abweichung.
Um die Bestimmung zu automatisieren wird als Metrik die Änderung des Mittelpunktes die letzten zehn Iterationen gewählt.
Ist die akkumulierte Änderung null, also haben die letzten zehn vorhergesagten Drehpunkte die selben Koordinaten, wird davon ausgegangen, dass dieser Punkt korrekt ist und die Prognose wird abgegeben.

Das andere Ende des Pendels wird vorerst durch den Punkt definiert dessen Distanz die größte zum prognostizierten Drehpunkt ist.
Dies dient nur zur besseren Visualisierung des erkannten Modells und ist für die eigentliche Aufgabe vorerst irrelevant, da ein Pendel noch keinen Mechanismus darstellt.

% TODO Bild.

Bisher wurden zur Ermittlung des kleinsten umfassenden Kreises aller bisher ermittelten Datenpunkte alle Datenpunkte verwendet.
Dies ist jedoch nicht notwendig, da die Kreise welche über den zeitlichen Verlauf hinweg gebildet werden nur jene Datenpunkte behalten werden müssen, welche zur Erstellung des Kreises notwendig sind.
Dies sind je nach Verteilung der Punktwolke entweder drei oder lediglich zwei Punkte.
Dafür wurde der genutzte Algorithmus angepasst, sodass er nicht mehr nur den Kreis, sondern auch die entsprechenden Koordinaten zurückgibt, welche für die Erstellung des entsprechenden Kreises genutzt wurden\footnote{Die entsprechende Änderung kann auf \aka{https://github.com/klawr/ba/commit/7209dfee5ab0a70470e22862f26f7c45046cd98f} nachvollzogen werden}.
Außerdem wird bei der Ermittlung des Kreises zwischen den bereits bekannten und der aktuell ermittelten Punktwolke unterschieden, sodass bei der Erweiterung der Liste der bekannten Punkte diese nicht mehrfach hinzugefügt werden.

% TODO wurde überhaupt schon eingeführt, dass es solche Tests gibt? Und wie die so aussehen? Man könnte außerdem hier davon sprechen wie ich diesen Test gemacht habe. Ich habe einfach in simulation unter step ein: 
% let counter = 0;
% function step(fn) {
%     counter++;
%     if (counter > 60) {
%         running = false;
%         console.log(ply.length)
%     }
% eingebaut. Das ist auch so ungefähr eine halbe Schwingung.
Diese Anpassung reduziert die Menge der Punkte die im ersten Test in einer Sekunde ermittelt werden von 19880 auf 294 Datenpunkte.
Von diesen 294 Datenpunkten sind lediglich 69 den bekannten Datenpunkten zuzuordnen.
Die anderen 225 Punkte lassen sich den gemessenen Veränderungen der letzten beiden verglichenen Bildern zuordnen, was in etwa dem Durchschnitt der Punkte in diesen Tests entspricht.
Ein weiterer Vorteil ergibt sich noch dadurch, dass Glieder welche sich mehrfach im selben Winkel befinden keine neuen Einträge zu den bekannten Punkten hinzufügen.
Ohne diesen Filter würde die Menge der Datenpunkte linear zunehmen, und die Dauer des Algorithmus, dessen Zeit ebenfalls linear zur Menge der Datenpunkte wächst, quadratisch wachsen.

% TODO Vergleich der Performance.

% TODO check das ° Zeichen ob das anständig gedruckt wird.
Dieser Ansatz erkennt für ein Glied das sich mindestens 180° um den definierten Punkt dreht ein sehr nahe am tatsächlichen Wert gelegenen Drehpunkt.
Der offensichtliche Nachteil besteht jedoch darin, dass alle Glieder die sich um weit weniger als 180° drehen mit Sicherheit kein gutes Ergebnis liefern.

Die Veränderung des Mittelpunktes des Kreises für den Bogen mit kleinerem Mittelpunktswinkel kann jedoch Aufschluss darüber geben, wo sich der tatsächliche Drehpunkt womöglich befinden könnte.
Diese Möglichkeit soll als nächstes untersucht werden.
% TODO Untersuch das.

% TODO Gerade Linie und dann Kreis.
% TODO Abhängigkeit von Bedeckter Fläche
% TODO Ermittlung von Schnittpunkten durch die geraden
% TODO Kathetensatz nach Euklid, welcher über h und q das b ermitteln kann, welches durch den Satz von Thales auf das a schließen kann welches mit q einen Schnittpunkt in B haben muss, wobei B bekanntenmaßen der Drehpunkt ist.
% TODO Das sollte bei steigendem h und q eine immer genauere Prognose von B geben können.

\subsection{Schnittpunkte von Linien}

Als ein weiterer Ansatz soll untersucht werden, ob der Drehpunkt durch die Schnittpunkte von ermittelten Linien gefunden werden kann.
Diese Linie soll durch die Momentaufnahmen bestimmt werden.

Als erster Ansatz soll die Linie genutzt werden, welche durch die am weitesten voneinander entfernten Punkte definiert wird.
Diese Linie sollte in etwa den selben Winkel haben wie der Winkel des tatsächlichen Gelenkes.
Eine Annahme die hierbe implizit getroffen wird, ist dass die Glieder länger sind als sie breit sind, wobei die Länge durch den Abstand der Gelenke definiert ist und die Breite entsprechend durch die Punkte welche normal zu der Längenlinie stehen.

Eine auf diese Weise definierte Linie wird dann in einer Liste gespeichert und die nächste Iteration folgt.
Bereits ab der zweiten Iteration können dann die Schnittpunkte aller Linien genutzt werden um den Drehpunkt zu bestimmen.

% TODO Koordinaten der einzelnen Schnittpunkte betrachten. X und Y sollten im Grunde eine Normalverteilung aufweisen. Dann muss auch nicht der Schwerpunkt genommen werden... Ist aber vermutlich weniger Rechenintensiv.

Idealerweise sollten alle Schnittpunkte die selben Koordinaten haben.
Da dies jedoch nicht der Fall ist, wird der Schwerpunkt aller Schnittpunkte ermittelt und dieser soll dann als Prognose benutzt werden.

Diese Methode liefert schnell Ergebnisse auch für Mittelpunktswinkel von weit unter 180°.

% /subsection{Ermittlung mehrerer am weitesten auseinander liegenden Punkte}.

Nachteilig ist jedoch, dass der Winkel durch die am weitesten voneinander entfernten Punkte sehr stark variiert, da wie in Abschnitt~\ref{ch:erkennung_von_änderungen} bereits erwähnt, bei dem Vergleich zweier zeitlich aufeinander folgenden Bilder sowohl die Position des ersten, als auch die Position des Pendels im zweiten Bild enthalten ist.
Um dieses Problem zu Umgehen sollen nun mehrere am weitesten auseinander liegenden Punkte ermittelt werden und die Prozedur mit diesen wiederholt werden.

% TODO hier sollte ein Bild vorher zu nachher eingefügt werden um diese Aussage zu untermauern.
Durch diese Änderung entspricht der jeweilige Winkel der definierten Linien eher dem tatsächlichen Winkel und der entsprechend resultierende Fehler wird hierdurch kleiner.
Damit reduziert sich auch die Abweichung zum daraus errechneten Drehpunkt.

\subsection{Methode der kleinsten Quadrate}

Eine weitere Methode jene Linie zu bestimmen welche genutzt werden soll um mit dessen Schnittpunkte den Drehpunkt zu ermitteln ist durch die \name{Methode der kleisten Quadrate}.
Die Linie die aus der Lösung dieser Methode resultiert entspricht der Linie welche den kleinsten Fehler gegenüber allen Punkten besitzt und wird auch als Ausgleichsgerade bezeichnet. % TODO Ist von Wiki sollte aber zitiert werden...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TODO Writing

Jedoch entsteht auch mit dieser Methode wieder ein weiteres Problem.
Wenn zwei Bilder die eine Drehung darstellen miteinander verglichen werden, indem jene Pixel behalten werden in denen eine Änderung zu erkennen ist, dann werden typischerweise mehr Änderungen erkannt, je weiter man sich radial von Drehpunkt entfernt.
Diese Beobachtung ist nicht überraschend, denn die absolute Geschwindigkeit eines Gelenkes nimmt mit länge des Gliedes zu, allerdings verzerrt es die Beobachtung ein wenig.
Hier kann jedoch eine Funktion abhilfe schaffen, die auch in der Bilderkennung durch neurale Netzwerke genutzt wird.
Diese als Non-Max Suppression % TODO writing...
bezeichnete Funktion wird eigentlich dafür genutzt, dass erkannte Objekte die im Bild direkt nebeneinander liegen gefiltert werden für das Bild, dass den höchsten Konfidenzwert besitzt.
Da den Pixeln hier kein Konfidenzwert zugeordnet werden kann, kann allerdings eine Funktion genutzt werden welche ähnlich wie die Non-Max Suppression Funktion %TODO oh mann...
die sich überlappenden Pixel in einem bestimmten Umkreis entfernt.
Dadurch wird die Dichte der erkannten Pixel quasi homogen und der Drehpunkt liegt etwas näher an dem tatsächlich erkannten, ohne viel Präzision bei der Bestimmung der Steigung in Kauf zu nehmen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Auch die Ausgleichsgerade basiert auf der Annahme, dass das betrachtete Glied länger ist als es breit ist.

Sie berechnet sich durch... % TODO
% TODO Formel.

Die vorgeschlagene Formel funktioniert nicht gut für nahezu senkrechte Steigungen.
Dies liegt an... % TODO
Deshalb wurde die Formel für alle Winkel über 45° angepasst, sodass die im Nenner die jeweilige Differenz zum Durchschnitt der Y-Achse berechnet wird.
Zum Spiegeln der Achsen werden außerdem der Zähler und Nenner zur Bestimmung der Steigung vertauscht.

% TODO Formel.

Wie bei den vorangegangen Methoden sollen dann die Schnittpunkte der so errechneten Linien genutzt werden um den Drehpunkt zu bestimmen.

\subsection{Vergleich zweier Kreise}

Die letzte Methode die untersucht werden soll ist\dots

\subsection{Auswertung der Beobachtungen}

% TODO Statistik Gedöhns und Beschreibung der unterschiedlichen Vor- und Nachteile

Die hier besprochenen Ansätze teilen die Annahme, das alle Punkte welche durch die Änderung betrachtet wurden zu dem selben Glied gehören.
Des weiteren wird davon ausgegangen, dass alle Glieder einen Drehpunkt haben.
Da die Definition eines Mechanismus mindestens 3 bewegliche Glieder benötigt, muss hierfür eine Lösung gefunden werden, die im folgenden Abschnitt untersucht wird.

