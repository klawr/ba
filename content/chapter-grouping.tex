% !TEX root = ../document.tex

\chapter{Zuordnung von Datenpunkten zu Gliedern} \label{ch:gruppierung_von_datenpunkten}

\cleanchapterquote{Eine Kinematische Kette ist die Aneinanderreihung wenigstens dreier durch Elementenpaare beweglich miteinander verbundener Glieder}{VDI2127}{Getriebetechnische Grundlagen}

Im vorangegangen Abschnitt wurde die Erkennung von Polen ebener Glider durch ihre Bewegung betrachtet.
Alle Methoden gingen jedoch davon aus, dass sich alle Datenpunkte einem Glied zuordnen lassen.
Es ist entsprechend notwendig bevor man die bereits besprochenen Methoden anwenden kann eine Zuordnung der Punkte in entsprechende Gruppen zu unternehmen, welche dann an die bekannten Methoden weiter gegeben werden können.
Die hier untersuchten Mechanismen folgen der Getriebedefinition aus~\cite[G167]{Grote2014} mit genau einem angetriebenem Glied.

Für eine solche Zuordnung von Gliedern werden verschiedene Ansätze untersucht.

\section{Zuordnung von Linien an Punkte}

Der erste Ansatz welcher untersucht wird geht von der Annahme aus, dass sich alle Punkte in etwa um sich auf Linien zurückzuführende Glieder herum befinden.
Diese Annahme ist ähnlich wie bei den vorangegangen Methoden, dass die Glieder immer länger sind als sie breit sind (s. Kapitel~\ref{ch:schnittpunkt_gerade}).

Hierfür wird ein Punkt aus den Datenpunkten genommen und dann eine Linie definiert welche am ehesten dem Glied entspricht welche diesem Punkt zugeordnet werden kann.
Dann werden alle Punkte genommen dessen Abstand zu dieser Linie kleiner ist als ein Schwellenwert, welcher vorher definiert werden muss.

Alle Punkte dessen Abstand unter diesem Schwellenwert sind werden dann der ersten Gruppen zugeordnet und der Prozess wird mit allen ungruppierten Punkten wiederholt.
Hierfür soll die Linie ähnlich zur Regressionsgerade bestimmt werden.
Als problematisch stellt sich jedoch heraus, dass die Regressionsgerade nicht zwischen Punkten unterscheiden kann welche vermutlich zu einem Glied des gewählten Punktes gehören und welche nicht.
Daher kann die Regressionsgerade in seiner bisher genutzten Form nicht genutzt werden.
Ein naiver Ansatz an dieser Stelle wäre die Berechnung des Fehlers der entsteht wenn eine Linie willkürlich in den Raum gelegt wird.
Der Fehler berechnet sich entsprechend durch die Summe der orthogonalen Abstände aller Punktes zu dieser Linie.
Damit Punkte welche weit von der Linie entfernt werden einen geringeren Einfluss auf den Fehler haben kann stattdessen eine Wurzel dessen berechnet werden.
Wenn man den Fehler für genug Linien im Winkel äquidistant zueinander auf diese Weise misst, kann die am besten passende Gerade gewählt werden und alle Punkte innerhalb des vorher angesprochenen Schwellenwertes dieser als Gruppe zugeordnet werden.

\begin{figure}
    \centering
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_0.png}
        \caption{}
        \label{fig:gruppe1_2_0}
    \end{subfigure}
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_1.png}
        \caption{}
        \label{fig:gruppe1_2_1}
    \end{subfigure}
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_2.png}
        \caption{}
        \label{fig:gruppe1_2_2}
    \end{subfigure}
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_3.png}
        \caption{}
        \label{fig:gruppe1_2_3}
    \end{subfigure}
    \caption[Versuch \lstinline{gruppe1_1.html}]{Versuch \lstinline{gruppe1_1.html}. In Bild~\ref{fig:gruppe1_2_0} wird der Mechanismus gezeigt, dessen Glieder nun zugeordnet werden sollen.
    Bild~\ref{fig:gruppe1_2_1} zeigt die Vorhersage zur Zuordnung dieser Punkte.
    Bild~\ref{fig:gruppe1_2_2} zeigt die Zuordnung der Punkte in den Totlagen des Mechanismus. Hier wird das linke Glied und die Koppel einer einzelnen Gruppe zugeordnet. Bild~\ref{fig:gruppe1_2_2} zeigt, dass der genutzte Algorithmus manchmal auch falsche vorhersagen trifft. Hier liegt das daran, dass zuerst die grüne Gruppe ermittelt wurde, bei welcher die Dichte der weit entfernten Punkte des Gelenkes des rechten Gliedes zu einer falschen Gerade geführt hat. Danach hat sich der Fehler in den übrigen Gruppen entsprechend fortgepflanzt.}
    \label{fig:gruppe1_2}
\end{figure}

Eine entsprechende Funktion um dies umzusetzen wurde auf der \lstinline{PointCloud} Klasse definiert.
Diese hält die Punkte vor, welche gruppiert werden sollen.
Ziel der Funktion ist es zunächst die Linien zu finden, welche den Mechanismus am ehesten repräsentieren.
Zunächst eine Kopie der Punkteliste erstellt.
Dann wird, solange es noch mehr als $10\%$ der initial ungruppierten Punkte gibt eine solche Linie ermittelt.
Es wird zunächst der Punkt gewählt welcher den geringsten Wert für die X-Koordinate aufweist.
Dann wird für eine festgelegte Anzahl an Linien welche alle im gleichen Winkel zueinander stehen und einen gemeinsamen Schnittpunkt in dem zuvor gewählten Punkt haben, die orthogonale Distanz aller anderen Punkte gemessen.
In Abbildung~\ref{fig:gruppe1_2} ist die Anzahl dieser Punkte 36, welche durch die grauen Linien gezeigt werden.
Von dieser orthogonale Distanz wird jeweils noch die dritte Wurzel genommen, damit Punkte die weiter weg von der geraden weniger Einfluss auf diese Summe haben.
Ziel ist es die Gerade zu finden, welche hierbei die geringste Summe aufweist, welcher als \lstinline{score} bezeichnet wird.
Ohne einen weiteren Ausgleichswert würden hier entsprechend jene Linien welche wenig Punkte treffen bevorzugt werden.
Daher wird der \lstinline{score} noch durch die Anzahl der Punkte geteilt, dessen Distanz zur Gerade unterhalb des Schwellenwertes liegt.

Der Schwellenwert so wie die Skalierung der Ausgleichswerte wurden experimentell bestimmt.
Es ist davon auszugehen, dass Mechanismen welche eine andere Form aufweisen als die \name{mec2} Modelle andere Schwellenwerte zur korrekten Berechnung benötigen würden.

Nachdem die entsprechenden Linien bestimmt wurden, wird als nächstes die auf der \lstinline{Line} Klasse definierte statische Funktion \lstinline{realignGroups} aufgerufen.
Diese bestimmt für jede der Gruppen die entsprechende Regressionsgerade.
Dann wird für jeder Punkt der Gerade zugeordnet, welche die geringste orthogonale Distanz aufweist.
Auf diese Weise werden die Punkte neu gruppiert.

\section{\name{k-Means} Algorithmus}\label{ch:kMeans}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{gfx/k_means_centroids_edit.png}
    \caption[Versuch \lstinline{gruppe2_1.html}]{Versuch \lstinline{gruppe2_1.html}. Das linke Bild zeigt den Mechanismus. Das mittlere Bild zeigt die Gruppen in jeweils unterschiedlichen Farben an. Die \name{Centroids} werden bei jeder Iteration grö{\ss}er um die Annäherung zu visualisieren. Es ist sichtbar, dass sie sie gegen einen Punkt konvertieren. Das rechte Bild zeigt einen darauffolgenden Aufruf des Algorithmus. Die \name{Centroids} des letzten Aufrufs werden hierbei als Ausgangspunkte gewählt. So bleiben die Gruppen über den Verlauf der Bildsequenz hinweg konstant. Entsprechend wandern die \name{Centroids} kaum über die internen Iterationen.}
    \label{fig:gruppe2_1}
\end{figure}

Eine andere Möglichkeit die Datenpunkte ihren Gruppen zuzuordnen ist durch den \name{k-Means} Algorithmus~\cite[S.~241]{Geron2019}.
Dieser wird in der Statistik genutzt um Datenpunkte in Gruppen einzuteilen.
Ein offensichtlier Nachteil dieses Ansatzes besteht darin, dass die Anzahl der Gruppen von vorneherein bekannt sein muss\footnote{Es gibt jedoch Methoden um diese Anzahl zu berechnen, zum Beispiel durch den Silhouettenkoeffizienten~\cite[S.~247]{Geron2019}.}.
Eine Untersuchung, ob er für den vorliegenden Anwedungsfall nutzbar ist scheint jedoch angebracht.
Eine entsprechende Funktion ist in der \lstinline{PointCloud} Klasse definiert.
Hier werden zunächst zufällig $k$ Punkte auf dem Bild ausgewählt.
Diese Punkte werden als \name{Centroids} bezeichnet.
Jeder Punkt der Punktwolke ordnet sich dann demjenigen \name{Centroid} zu, welcher die geringste euklidische Distanz aufweist.
Dies sollte ein bis drei Gruppen zur Folge haben, welche die entsprechenden Punkte enthalten.
Daraufhin werden neue \name{Centroids} definiert, indem der Erwartungswert dieser Gruppen ermittelt wird.
Dieser Vorgang soll sich dann eine festgelegte Anzahl an Iterationen wiederholen.

Als eine Erweiterung des \name{k-Means} Algorithmus könnte noch der EM-Algorithmus untersucht werden, welcher weniger das Problem hat Gruppen von unterschiedlicher Grö{\ss}e zu erstellen~\cite[S.~262]{Geron2019}.
Dies wird jedoch an dieser Stelle nicht mehr getan.

\section{Dijkstra-Algorithmus}\label{ch:dijkstra}

Die letzte Variante die hier untersucht werden soll um die Glieder des Mechanismus in entsprechende Gruppen zu zerteilen ist die Zuordnung aller Datenpunkte zueinander.
Hierfür soll das \lstinline{PointCloud} Objekt in einen Graphen überführt werden welcher dann über den \name{Dijkstra-Algorithmus} Pfade definiert.
Anschlie{\ss}end werden diese Pfade genutzt um Geraden zu definieren welche dann Rückschluss auf die zugrundeliegenden Gruppen geben können.

Zur Durchführung des Dijkstra-Algorithmus wurde die \lstinline{Dijkstra} Klasse definiert.
Der Konstruktor dieser Klasse nimmt hierfür ein Objekt der \lstinline{PointCloud} Klasse und ein Objekt welches eine X- und Y-Koordinate hat entgegen, welcher hier als \lstinline{anchor} bezeichnet werden soll.
Ziel ist es den kürzesten Pfad zu bestimmen um vom \lstinline{anchor} zu jedem Punkt des übergebenen \lstinline{PointCloud} Objektes zu gelangen.
Der offensichtliche kürzeste Weg ist laut der Dreiecksungleichung natürlich immer der direkte Weg vom \lstinline{anchor} zum entsprechenden Punkt.
Deshalb sollen die Distanzen zwischen den Werten jeweils potenziert werden.
An den Konstruktur kann dafür der Parameter \lstinline{warp} übergeben werden, welcher standardmä{\ss}ig den Wert zwei einnimmt.
Dieser \lstinline{warp} Parameter unterscheidet sich von der traditionellen Implementation des \name{Dijkstra-Algorithmus}.
Diese Anpassung ist jedoch notwendig, da hier keine Annahmen über die Verbindungen einzelner Datenpunkte gemacht werden kann, sondern der Pfad jedes Punktes zu jedem anderem gemessen wird.
Hierfür wird der Graph gebildet indem alle Objekte des übergebenen \lstinline{PointCloud} Objektes in ein Objekt überführt werden welche in Listing~\ref{lst:dijkstra_points_graph} gesehen werden kann.

\begin{lstlisting}[language=JavaScript, caption={Im \lstinline{Dijkstra} Konstruktor werden die Punkte des übergebenen \lstinline{PointCloud} Objektes in einen Graphen überführt.}, label={lst:dijkstra_points_graph}]
const compEdges = (p) => points
    .map((sp, sidx) => ({
        target: sidx,
        weight: Dijkstra.euclDistance(p, sp) ** warp,
    }))
    .sort((a, b) => a.weight - b.weight)
    .slice(1, numEdges + 1);

const graph = points.map((p, id) => ({
    id,
    dist: Infinity,
    known: false,
    edges: compEdges(p),
    pred: -1,
}));
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{gfx/dijkstra_edit.png}
    \caption[Versuch \lstinline{gruppe3_2.html}]{Versuch \lstinline{gruppe3_2.html}. Das linke Bild zeigt den Mechanismus. Das mittlere Bild zeigt die Verbindung des lstinline{anchor}, welcher im linken Gestellpunkt ist. Die Farbe der Verbindung zwischen den Punkte weist auf den \lstinline{dist} Wert hin.
    Wie im rechten Bild zu sehen ist, werden die Verbindungen bei sehr kleinen eingeschlossenen Winkeln fehlerbehaftet.}
    \label{fig:gruppe3_1}
\end{figure}

Die \lstinline{id} entspricht dem Index des Punktes innerhalb der \lstinline{points} Liste.
\lstinline{dist} beschreibt die Distanz welche zum entsprechendem \lstinline{anchor} ermittelt wurde.
Hierbei ist zu beachten, dass es sich nicht um die tatsächliche Distanz, sondern um die Summe der Einzelpfade handelt, welche jeweils mit \lstinline{warp} potenziert werden.
Diese Wert ist also eher als Wert zum Vergleichen mit anderen Punkten zu verstehen.
Er ist initial \lstinline{Infinity}, damit er später bis zum kleinsten gefundenen Pfad reduziert werden kann.
\lstinline{known} wird genutzt um bei der Berechnung jene Punkte überspringen zu können dessen \lstinline{dist} Wert bereits ermittelt wurde.
Die \lstinline{edges} Eigenschaft hält von jedem Punkt jeden anderen Punkt mittels des entsprechenden Index und der Distanz vor.
Diese Distanz wird hier als \lstinline{weight} bezeichnet um zu unterstreichen, dass es nicht die euklidische Distanz ist, sondern diese mit dem \lstinline{warp} Parameter potenziert wird.
Zuletzt wird \lstinline{pred} genutzt um jeweils der Vorgänger jedes Knotens auf dem Graphen betiteln zu können.

Daraufhin wird dieser Graph als \lstinline{unvisited} kopiert um alle unbesuchten Punkte festhalten zu können.
Dieser kopierten Liste wird der \lstinline{anchor} an den Start angefügt\footnote{Mit der \lstinline{id} $-1$ und einer \lstinline{dist} von 0.}.

\begin{lstlisting}[language=JavaScript, caption={Berechnung der \lstinline{dist} Eigenschaft der einzelnen Objekte aus dem Dijkstra-Graphen.}, label={lst:creation_dijkstra_graph}]
while (unvisited.length) {
    unvisited.sort((a, b) => a.dist - b.dist);
    const u = unvisited.shift();
    u.known = true;

    for (const { ldist, o } of u.edges
        .map(e => ({ ldist: e.weight, o: graph[e.target] }))
        .filter(({ o }) => !o.known)) {
        const cdist = u.dist + ldist;
        if (cdist < o.dist) {
            o.dist = cdist;
            o.pred = u;
        }
    }
}
\end{lstlisting}

Hier wird es sich zu nutze gemacht, dass Obwohl die Liste \lstinline{unvisited} nur eine Kopie von \lstinline{graph} ist, die Referenzen der einzelnen darin enthaltenen Objekte jedoch jeweils die selben sind.
So können die Elemente in \lstinline{unvisited} dort jeweils der \lstinline{dist} nach aufsteigend sortiert und verschoben werden und die Objekte in \lstinline{graph} werden hierbei mit Information gefüllt.
Das Sortieren lässt die Objekte mit aufsteigener Distanz in \lstinline{unvisited} erscheinen.
Das erste Objekt wird entsprechend aus der Liste entfernt und die \lstinline{known} Eigenschaft wird auf \lstinline{true} gesetzt.
Bei der ersten Iteration ist dies in jedem Fall \lstinline{anchor}.
Daraufhin wird für jedes Element in der \lstinline{edges} Liste des entsprechenden Punktes die Distanz mit seiner eigenen addiert.
Nach der ersten Iteration ist also davon auszugehen, dass jeder Punkt direkt mit dem \lstinline{anchor} verbunden ist.
Bei der zweiten Iteration werden alle Punkte aus \lstinline{unvisited} wieder sortiert und jeder Punkt der nun zusammen mit der Distanz dieses Punktes eine kürzere Distanz aufweist wird seinen \lstinline{dist} und entsprechend den \lstinline{pred} Wert aktualisieren.
Dadurch, dass die \lstinline{dist} jeweils potenziert wird passiert dies bis alle Punkte durchlaufen wurden.

\subsection{Nutzung des Korrelationskoeffizienten}

Der Graph erstellt für die Punktwolke einen Pfad für jeden Punkt zu dem \lstinline{anchor}.
Dieser Pfad soll jetzt dazu genutzt werden um eine Linie zu bilden.
Die Idee ist, dass wenn man die äu{\ss}ersten Punkte des Graphen nimmt um von diesen zum \lstinline{anchor} wandert, dann werden hierdurch Pfade gebildet welche keine Ausläufer haben.

\begin{lstlisting}[language=JavaScript, caption={Bestimmung der äu{\ss}ersten Knoten zur Bestimmung von Geraden durch den Korrelationskoeffizienten in der \lstinline{groupsByCorrelation} Funktion innerhalb der \lstinline{Dijkstra} Klasse.}, label={lst:dijkstra_correlation_part1}]
let ends = this.graph
    .filter((n) => !this.graph.some(g => g.pred.id === n.id))
    .sort((a, b) => b.dist - a.dist);

const winner = [];

while (ends.length) {
    const occupied = (function f(o, arr) {
        if (o.pred) arr = f(o.pred, arr);
        return [...arr, o];
    })(ends[0], []);
    winner.push(ends.shift());

    ends = ends.filter(u => {
        for (let p = u.pred; p.pred; p = p.pred)
            if (occupied.includes(p)) return false;
        return true;
    });
}
\end{lstlisting}

Hierfür werden zunächst die Knoten im Graphen gesucht, welche keinen Vorgänger haben.
Dann wird eine Liste dieser, welche als \lstinline{ends} bezeichnet wird, der \lstinline{dist} nach absteigend sortiert.
Diese Liste wird dann gefiltert, indem der Punkt der jeweils die grö{\ss}te Distanz hat andere Punkte filtert, nach dem Prädikat ob diese, oder rekursiv dessen \lstinline{pred} Eigenschaften gemeinsame Vorgänger haben.

Dieser Vorgang wird solange wiederholt, bis die \lstinline{ends} Liste leer ist, sodass nurnoch äu{\ss}ere Knoten vorgehalten werden welche keine gemeinsamen Vorgänger zum \lstinline{anchor} haben.

Diese als \lstinline{winner} bezeichneten Knoten werden dann über ihre Vorgänger iterieren um zu prüfen ob sich mit diesen eine Gerade bilden lässt.

\begin{lstlisting}[language=JavaScript, caption={Bestimmung der äu{\ss}ersten Knoten zur Bestimmung von Geraden durch den Korrelationskoeffizienten in der \lstinline{groupsByCorrelation} Funktion innerhalb der \lstinline{Dijkstra} Klasse.}, label={lst:dijkstra_correlation_part2}]
let lines = [];
for (const win of winner) {
    let group = [];
    for (let u = win; u.pred; u = u.pred) {
        const correlation = PointCloud.correlation(
            [...group, this.points[u.id]]);
        if (Math.abs(correlation) ** group.length < minCorr) {
            if (group.length > 2 &&
                group.length > this.points.length * minPercent) {
                lines.push(Line.fromRegressionLine(group, g));
            }
            group = [];
        }
        group.push(this.points[u.id]);
    }
    lines.push(Line.fromRegressionLine(group, g));
}
\end{lstlisting}

Die Punkte werden auf ihre nähe zu einer Regressionsgeraden über den Korrelationskoeffizienten geprüft.
Der Korrelationskoeffizient berechnet sich durch~\cite{Papula2014}

\begin{equation}
    r = \left(\left(\sum_{i=1}^n x_i y_i\right) - n \bar{x} \bar{y}\right) \div \sqrt{\left(\sum_{i=1}^n x_i^2 - n\bar{x}^2\right)\left(\sum_{i=1}^n y_i^2 - n \bar{y}^2\right)}
    \label{eq:korrelationskoeffizient}
\end{equation}

und dessen Berechnung ist als statische Funktion auf der \lstinline{PointCloud} definiert.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{gfx/correlation_edit.png}
    \caption[Versuch \lstinline{gruppe3_3.html}]{Versuch \lstinline{gruppe3_3.html}. Das linke Bild zeigt den Mechanismus. Das mittlere Bild zeigt die Regressionsgeraden welche durch die vorgeschlagene Methode meistens ermittelt werden. Das rechte Bild zeigt einen entsprechenden Fehler, welcher der falschen Zuordnung der Pfade im Graphen zugrunde liegt.}
    \label{fig:gruppe3_3}
\end{figure}

In Listing~\ref{lst:dijkstra_correlation_part2} wird für jeden Eintrag aus \lstinline{winner} der Vorgänger gewählt und diese werden einer Liste \lstinline{group} hinzugefügt.
Für diese Gruppe an Punkten wird dann der Korrelationskoeffizient bemessen.
Ist dieser niederiger als der Schwellenwert wird noch geprüft ob eine Mindestanzahl an Punkten erreicht ist, damit aus diesen dann die Regressionsgerade gebildet werden kann\footnote{Der Standardwert für den Schwellenwert der Regressionsgeraden liegt bei $0.6$ und die Mindestanzahl an Punkten liegt bei $10\%$ der Gesamtzahl der Punkte des Graphen.}.

Diese Geraden werden dann vorgehalten und könnten für weitere Analysen genutzt werden.

\section{Rekonstruktion eines Mechanismus durch die Relativpole}

Die vorangegangen Methoden geben scheinbar akzeptable Ergebnisse für Viergelenke.
Sie scheitern jedoch, sobald die Anzahl der Glieder höher wird, wie in Abbildung~\ref{fig:gruppe1_3_2_6_3_4} gesehen werden kann.

\begin{figure}
    \includegraphics[width=\textwidth]{gfx/gruppe_failed_edit.png}
    \caption[Versuche \name{gruppe1\_3.html}, \name{gruppe2\_6.html} und \name{gruppe3\_4.html}.]{Links ist der Ausgangsmechanismus, welcher durch die Wattsche Kette gebildet wird. Von links nach rechts sind jeweils der Versuch \name{gruppe1\_3.html}, welcher so offensichtlich keine nutzbaren Ergebnisse hervorbringt, \name{gruppe2\_6.html}, welcher etwas bessere Ergebnisse zeigt und der Versuch \name{gruppe3\_4.html}, welcher hier die stabilsten Ergebnisse zu produzieren scheint scheint, jedoch sind auch diese für weitere Analysen kaum brauchbar.}
    \label{fig:gruppe1_3_2_6_3_4}
\end{figure}

Aus diesem Grund soll nun davon ausgegangen werden, dass sowohl die Ermittlung der Gliedebenen also auch die dazugehörigen Momentanpole erfolgreich ermittelt wurden.

\subsection{Ermittlung der Anzahl der gesuchten Punkte}

Der Freiheitsgrad für einen planaren Mechanismus berechnet sich nach Grübler durch

\begin{equation}
    F = 3n - 3 - b_1 - 2b_2
    \label{eq:gruebler}
\end{equation}

wobei $F$ den Freiheitsgrad, $n$ die Anzahl der Glieder und der $b$-Index jeweils die Wertigkeit dieses Gelenkes darstellt.
Hierbei sei anzumerken, dass ein $b_1$ jederzeit durch zwei $b_2$ ersetzt werden kann, wenn man entsprechend auch die Gliederzahl $n$ um eins erhöht, was durch

\begin{equation}
    \begin{split}
        F &= 3((n+c)-1) - (b_1 - c) - 2(b_2 + 2c) \\
        F &= 3n + 3c - 3 - b_1 + c - 2b_2 - 4c \\
        F &= 3n - 3 - b_1 - 2b_2
    \end{split}
\end{equation}

gezeigt wird.
$c$ kann hierbei beliebig, also auch als $c = b_1$, gewählt werden.
Entsprechend darf in den folgenden Überlegungen von lediglich zweiwertigen Gelenken ausgegangen werden.
Aus der Annahme heraus, dass die hier betrachteten Mechanismen jeweils zwangläufige Mechanismen mit genau einem angetriebenem Glied sind lässt sich diese Gleichung durch

\begin{equation}
    \begin{split}
        1 &= 3n - 3 - 2b_2 \\
        b_2 &= \frac{3n}{2} - 2
    \end{split}
\end{equation}

vereinfachen.
So kann neben der Anzahl der gesuchten Gelenke des weiteren festgestellt werden, dass die Gliederzahl der hier für die Berechnung genutzten kinematischen Ketten in jedem Fall einer geraden Zahl entspricht.


\subsection{Betrachtung aller Relativpole}

Die gemeinsame Drehung zweier Gliedebenen geschieht jeweils um einen Relativpol.
Entsprechend sind alle gesuchten Gelenke auch Relativpole.
Die Anzahl der Relativpole eines Mechanismus berechnet sich durch~\cite{Goessner2016}

\begin{equation}
    k = \frac{n}{2}(n-1)
    \label{eq:anzahl_pole}
\end{equation}

Wobei $n$ hier wieder die Anzahl der Glieder ist.
Hier lassen sich in jedem Fall die durch die in den angeführten Methoden bestimmten Momentanpole der bewegten Gliedebenen ausschlie{\ss}en, wobei die Absolutpole dann direkt als gefundene Gelenke identifiziert werden können.

Allerdings ist auch zu beachten, dass sobald ein Relativpol durch den Schnittpunkt zweier Gliedebenen definiert ist welche mehr als einen Absolutpol als Parameter besitzen kein Gelenk sein kann, da er sonst starr wäre.
Die Relativpole welche durch zwei nicht benachbarte Gliedebenen gebildet werden lassen sich dennoch nicht einfach ausschlie{\ss}en, sodass hier weitere Analysen notwendig sein werden.

\begin{figure}
    \includegraphics[width=\textwidth]{gfx/gruppe4_3_edit.png}
    \caption[Versuch \name{gruppe4\_3.html}]{Versuch \name{gruppe4\_3.html}. Links ist der Ausgangsmechanismus. Fast alle Relativpole können durch die genannten Methoden als Gelenke ausgeschlossen werden. Jedoch bilden die nicht benachbarten Gliedebenen hier zwei weitere Kandidaten welche ohne weitere Analyse nicht ausgeschlossen werden können.}
    \label{fig:gruppe4_3}
\end{figure}

Nach dem Satz von Aronhold-Kennedy~\cite{Goessner2016, Kerle2016}, welcher auch als 3-Polsatz bezeichnet wird, befinden sich für drei bewegte Gliedebenen jeweils drei Relativpole auf einer Geraden.
Die Punkte welche nicht ausgeschlossen werden können bewegen sich entsprechend auf diesen Geraden.
Eine Analyse des Momentanpols dieser Punkte würde diesen entsprechend in unendlicher Distanz äquivalent zur translativen Bewegung identifizieren, sodass auch diese ausgeschlossen werden können.

Die gleichen Methoden können auch genutzt werden, wenn der Mechanismus translativ bewegende Glieder enthält, was in den Versuchen \name{gruppe4\_4} und \name{gruppe4\_5} gezeigt wird.
Die translativen Elemente können ausgeschlossen werden, weil jenes welches am Gestell befestigt ist bereits als Absolutpol ermittelt wurde.
Es sei jedoch darauf hingewiesen, dass Glieder welche translativ sind aber nicht am Gestellt befestigt sind hier ausgeschlossen sind.

\section{Auswertung der Ergebnisse}

Die vorgeschlagenen Methoden zeigen Mängel in der Genauigkeit.
Entsprechend sollen für die Auswertung lediglich Viergelenke untersucht werden.

% TODO auswerten
