% !TEX root = ../document.tex

\chapter{Zuordnung von Datenpunkten zu Gliedern} \label{ch:gruppierung_von_datenpunkten}

\cleanchapterquote{Eine Kinematische Kette ist die Aneinanderreihung wenigstens dreier durch Elementenpaare beweglich miteinander verbundener Glieder}{VDI2127}{Getriebetechnische Grundlagen}

Im vorangegangen Abschnitt wurde die Erkennung von Polen ebener Glider durch ihre Bewegung betrachtet.
Alle Methoden gingen jedoch davon aus, dass sich alle Datenpunkte einem Glied zuordnen lassen.
Es ist entsprechend notwendig bevor man die bereits besprochenen Methoden anwenden kann eine Zuordnung der Punkte in entsprechende Gruppen zu unternehmen, welche dann an die bekannten Methoden weiter gegeben werden können.

Für eine solche Gruppierung können verschiedene Ansätze herangezogen werden.

\section{Zuordnung von Linien an Punkte}

Der erste Ansatz welcher untersucht wird geht von der Annahme aus, dass sich alle Punkte in etwa um sich auf Linien zurückzuführende Glieder herum befinden.
Diese Annahme ist ähnlich wie bei den vorangegangen Methoden, dass die Glieder immer länger sind als sie breit sind (s. Kapitel~\ref{ch:schnittpunkt_gerade}).

Hierfür wird ein Punkt aus den Datenpunkten genommen und dann eine Linie definiert welche am ehesten dem Glied entspricht welche diesem Punkt zugeordnet werden kann.
Dann werden alle Punkte genommen dessen Abstand zu dieser Linie kleiner ist als ein Schwellenwert, welcher vorher definiert werden muss.

Alle Punkte dessen Abstand unter diesem Schwellenwert sind werden dann der ersten Gruppen zugeordnet und der Prozess wird mit allen ungruppierten Punkten wiederholt.
Hierfür soll die Linie ähnlich zur Regressionsgerade bestimmt werden.
Als problematisch stellt sich jedoch heraus, dass die Regressionsgerade nicht zwischen Punkten unterscheiden kann welche vermutlich zu einem Glied des gewählten Punktes gehören und welche nicht.
Daher kann die Regressionsgerade in seiner bisher genutzten Form nicht genutzt werden.
Ein naiver Ansatz an dieser Stelle wäre die Berechnung des Fehlers der entsteht wenn eine Linie willkürlich in den Raum gelegt wird.
Der Fehler berechnet sich entsprechend durch die Summe der orthogonalen Abstände aller Punktes zu dieser Linie.
Damit Punkte welche weit von der Linie entfernt werden einen geringeren Einfluss auf den Fehler haben kann stattdessen eine Wurzel dessen berechnet werden.
Wenn man den Fehler für genug Linien im Winkel äquidistant zueinander auf diese Weise misst, kann die am besten passende Gerade gewählt werden und alle Punkte innerhalb des vorher angesprochenen Schwellenwertes dieser als Gruppe zugeordnet werden.

\begin{figure}
    \centering
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_0.png}
        \caption{}
        \label{fig:gruppe1_2_0}
    \end{subfigure}
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_1.png}
        \caption{}
        \label{fig:gruppe1_2_1}
    \end{subfigure}
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_2.png}
        \caption{}
        \label{fig:gruppe1_2_2}
    \end{subfigure}
    \begin{subfigure}[t]{0.24\textwidth}
        \includegraphics[width=\textwidth]{gfx/gruppe1_2_3.png}
        \caption{}
        \label{fig:gruppe1_2_3}
    \end{subfigure}
    \caption[Versuch \lstinline{gruppe1_1.html}]{Versuch \lstinline{gruppe1_1.html}. In Bild~\ref{fig:gruppe1_2_0} wird der Mechanismus gezeigt, dessen Glieder nun zugeordnet werden sollen.
    Bild~\ref{fig:gruppe1_2_1} zeigt die Vorhersage zur Zuordnung dieser Punkte.
    Bild~\ref{fig:gruppe1_2_2} zeigt die Zuordnung der Punkte in den Totlagen des Mechanismus. Hier wird das linke Glied und die Koppel einer einzelnen Gruppe zugeordnet. Bild~\ref{fig:gruppe1_2_2} zeigt, dass der genutzte Algorithmus manchmal auch falsche vorhersagen trifft. Hier liegt das daran, dass zuerst die grüne Gruppe ermittelt wurde, bei welcher die Dichte der weit entfernten Punkte des Gelenkes des rechten Gliedes zu einer falschen Gerade geführt hat. Danach hat sich der Fehler in den übrigen Gruppen entsprechend fortgepflanzt.}
    \label{fig:gruppe1_2}
\end{figure}

Eine entsprechende Funktion um dies umzusetzen wurde auf der \lstinline{PointCloud} Klasse definiert.
Diese hält die Punkte vor, welche gruppiert werden sollen.
Ziel der Funktion ist es zunächst die Linien zu finden, welche den Mechanismus am ehesten repräsentieren.
Zunächst eine Kopie der Punkteliste erstellt.
Dann wird, solange es noch mehr als $10\%$ der initial ungruppierten Punkte gibt eine solche Linie ermittelt.
Es wird zunächst der Punkt gewählt welcher den geringsten Wert für die X-Koordinate aufweist.
Dann wird für eine festgelegte Anzahl an Linien welche alle im gleichen Winkel zueinander stehen und einen gemeinsamen Schnittpunkt in dem zuvor gewählten Punkt haben, die orthogonale Distanz aller anderen Punkte gemessen.
In Abbildung~\ref{fig:gruppe1_2} ist die Anzahl dieser Punkte 36, welche durch die grauen Linien gezeigt werden.
Von dieser orthogonale Distanz wird jeweils noch die dritte Wurzel genommen, damit Punkte die weiter weg von der geraden weniger Einfluss auf diese Summe haben.
Ziel ist es die Gerade zu finden, welche hierbei die geringste Summe aufweist, welcher als \lstinline{score} bezeichnet wird.
Ohne einen weiteren Ausgleichswert würden hier entsprechend jene Linien welche wenig Punkte treffen bevorzugt werden.
Daher wird der \lstinline{score} noch durch die Anzahl der Punkte geteilt, dessen Distanz zur Gerade unterhalb des Schwellenwertes liegt.

Der Schwellenwert so wie die Skalierung der Ausgleichswerte wurden experimentell bestimmt.
Es ist davon auszugehen, dass Mechanismen welche eine andere Form aufweisen als die \name{mec2} Modelle andere Schwellenwerte zur korrekten Berechnung benötigen würden.

% TODO link zum Quellcode

% TODO testen wie hier die Momentanpole ermittelt werden.

\section{k-Means-Algorithmus}

Eine andere Möglichkeit die Datenpunkte ihren Gruppen zuzuordnen ist durch den \name{k-Means-Algorithmus}~\cite[S.~241]{Geron2019}.
Dieser wird in der Statistik genutzt um Datenpunkte in Gruppen einzuteilen.
Ein offensichtlier Nachteil dieses besteht darin, dass die Anzahl der Gruppen von vorneherein bekannt sein muss.
Eine Untersuchung, ob er für den vorliegenden Anwedungsfall nutzbar ist scheint jedoch angebracht.
Eine entsprechende Funktion wurde wieder auf der \lstinline{PointCloud} Klasse definiert.
Hier werden zunächst zufällig drei Punkte auf dem Bild ausgewählt.
Diese drei Punkte werden als \name{Centroids} bezeichnet.
Jeder Punkt der Punktwolke ordnet sich dann demjenigen \name{Centroid} zu, welcher die geringste euklidische Distanz aufweist.
Dies sollte ein bis drei Gruppen zur Folge haben, welche die entsprechenden Punkte enthalten.
Daraufhin werden neue \name{Centroids} definiert, indem der Erwartungswert dieser Gruppen ermittelt wird.
Dieser Vorgang soll sich dann eine festgelegte Anzahl an Iterationen wiederholen.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{gfx/k_means_centroids_edit.png}
    \caption[Versuch \lstinline{gruppe2_1.html}]{Versuch \lstinline{gruppe2_1.html}. Das linke Bild zeigt den Mechanismus. Das mittlere Bild zeigt die Gruppen in jeweils unterschiedlichen Farben an. Die \name{Centroids} werden bei jeder Iteration grö{\ss}er um die Annäherung zu visualisieren. Es ist sichtbar, dass sie sie gegen einen Punkt konvertieren. Das rechte Bild zeigt einen darauffolgenden Aufruf des Algorithmus. Die \name{Centroids} des letzten Aufrufs werden hierbei als Ausgangspunkte gewählt. So bleiben die Gruppen über den Verlauf der Bildsequenz hinweg konstant. Entsprechend wandern die \name{Centroids} kaum über die internen Iterationen.}
    \label{fig:gruppe2_1}
\end{figure}

Um die Anzahl der Gruppen zu bestimmen kann eine Metrik verwendet werden welche als Trägheit bezeichnet wird.
Die Trägheit berechnet sich hier durch die durchschnittliche Distanz der Punkte zu ihrem jeweiligen \name{Centroid}.
Wird die Trägheit der einzelnen Gruppen auf einen Graphen gezeichnet, so ist die Anzahl zu bevorzugen welche eine starke Änderung der Trägheit im Verhältnis zu den anderen Anzahlen aufweist.
Auf dem Graphen ist dies als ein Knick zu sehen, weshalb dies auch als Ellbogenmethode bezeichnet wird.

Eine andere Herangehensweise zur Bestimmung der korrekten Anzahl an Gruppen ist der Silhouettenwert.
Dieser zeigt für die entsprechende Anzahl der Gruppen einen Wert zwischen $-1$ und $1$ an.
Ein Silhouettenwert von eins zeigt an, dass der Datenpunkt mitten in der Gruppe ist.
Ein Wert von null zeigt an, dass der Datenpunkt sich am Rand der Gruppe befindet.
Ein Wert von $-1$ zeigt hingegen an, dass der Datenpunkt vermutlich der falschen Gruppe zugeordnet wurde.

% TODO Der Silhouettenwert sollte genutzt werden können um die Regressionsgerade besser bestimmen zu können.

Diese Werte zu bestimmen kann die Möglichkeit geben die Regressionsgeraden entsprechend zu beeinflussen, womit die Regressionsgeraden welche durch die gruppierten \lstinline{PointCloud} Objekte gebildet werden um bessere Ergebnisse zu erzielen.

Als eine Erweiterung des \name{k-Means} Algorithmus könnte noch der EM-Algorithmus untersucht werden, welcher weniger das Problem hat Gruppen von unterschiedlicher Grö{\ss}e zu erstellen.
Dies wird jedoch an dieser Stelle nicht mehr getan.
% TODO Zitat und so.

\section{Dijkstra-Algorithmus}

Die letzte Variante die hier untersucht werden soll um die Glieder des Mechanismus in entsprechende Gruppen zu zerteilen ist die Zuordnung aller Datenpunkte zueinander.
Hierfür soll das \lstinline{PointCloud} Objekt in einen Graphen überführt werden welcher dann über den \name{Dijkstra-Algorithmus} Pfade definiert.
Anschlie{\ss}end werden diese Pfade genutzt um Geraden zu definieren welche dann Rückschluss auf die zugrundeliegenden Gruppen geben können.

Zur Durchführung des Dijkstra-Algorithmus wurde die \lstinline{Dijkstra} Klasse definiert.
Der Konstruktor dieser Klasse nimmt hierfür ein Objekt der \lstinline{PointCloud} Klasse und ein Objekt welches eine X- und Y-Koordinate hat entgegen, welcher hier als \lstinline{anchor} bezeichnet werden soll.
Ziel ist es den kürzesten Pfad zu bestimmen um vom \lstinline{anchor} zu jedem Punkt des übergebenen \lstinline{PointCloud} Objektes zu gelangen.
Der offensichtliche kürzeste Weg ist laut der Dreiecksungleichung natürlich immer der direkte Weg vom \lstinline{anchor} zum entsprechenden Punkt.
Deshalb sollen die Distanzen zwischen den Werten jeweils potenziert werden.
An den Konstruktur kann dafür der Parameter \lstinline{warp} übergeben werden, welcher standardmä{\ss}ig den Wert zwei einnimmt.
Dieser \lstinline{warp} Parameter unterscheidet sich von der traditionellen Implementation des \name{Dijkstra-Algorithmus}.
Diese Anpassung ist jedoch notwendig, da hier keine Annahmen über die Verbindungen einzelner Datenpunkte gemacht werden kann, sondern der Pfad jedes Punktes zu jedem anderem gemessen wird.
Hierfür wird der Graph gebildet indem alle Objekte des übergebenen \lstinline{PointCloud} Objektes in ein Objekt überführt werden welche in Listing~\ref{lst:dijkstra_points_graph} gesehen werden kann.

\begin{lstlisting}[language=JavaScript, caption={Im \lstinline{Dijkstra} Konstruktor werden die Punkte des übergebenen \lstinline{PointCloud} Objektes in einen Graphen überführt.}, label={lst:dijkstra_points_graph}]
const compEdges = (p) => points
    .map((sp, sidx) => ({
        target: sidx,
        weight: Dijkstra.euclDistance(p, sp) ** warp,
    }))
    .sort((a, b) => a.weight - b.weight)
    .slice(1, numEdges + 1);

const graph = points.map((p, id) => ({
    id,
    dist: Infinity,
    known: false,
    edges: compEdges(p),
    pred: -1,
}));
\end{lstlisting}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{gfx/dijkstra_edit.png}
    \caption[Versuch \lstinline{gruppe3_2.html}]{Versuch \lstinline{gruppe3_2.html}. Das linke Bild zeigt den Mechanismus. Das mittlere Bild zeigt die Verbindung des lstinline{anchor}, welcher im linken Gestellpunkt ist. Die Farbe der Verbindung zwischen den Punkte weist auf den \lstinline{dist} Wert hin.
    Wie im rechten Bild zu sehen ist, werden die Verbindungen bei sehr kleinen eingeschlossenen Winkeln fehlerbehaftet.}
    \label{fig:gruppe3_1}
\end{figure}

Die \lstinline{id} entspricht dem Index des Punktes innerhalb der \lstinline{points} Liste.
\lstinline{dist} beschreibt die Distanz welche zum entsprechendem \lstinline{anchor} ermittelt wurde.
Hierbei ist zu beachten, dass es sich nicht um die tatsächliche Distanz, sondern um die Summe der Einzelpfade handelt, welche jeweils mit \lstinline{warp} potenziert werden.
Diese Wert ist also eher als Wert zum Vergleichen mit anderen Punkten zu verstehen.
Er ist initial \lstinline{Infinity}, damit er später bis zum kleinsten gefundenen Pfad reduziert werden kann.
\lstinline{known} wird genutzt um bei der Berechnung jene Punkte überspringen zu können dessen \lstinline{dist} Wert bereits ermittelt wurde.
Die \lstinline{edges} Eigenschaft hält von jedem Punkt jeden anderen Punkt mittels des entsprechenden Index und der Distanz vor.
Diese Distanz wird hier als \lstinline{weight} bezeichnet um zu unterstreichen, dass es nicht die euklidische Distanz ist, sondern diese mit dem \lstinline{warp} Parameter potenziert wird.
Zuletzt wird \lstinline{pred} genutzt um jeweils der Vorgänger jedes Knotens auf dem Graphen betiteln zu können.

Daraufhin wird dieser Graph als \lstinline{unvisited} kopiert um alle unbesuchten Punkte festhalten zu können.
Dieser kopierten Liste wird der \lstinline{anchor} an den Start angefügt\footnote{Mit der \lstinline{id} $-1$ und einer \lstinline{dist} von 0}.

\begin{lstlisting}[language=JavaScript, caption={Berechnung der \lstinline{dist} Eigenschaft der einzelnen Objekte aus dem Dijkstra-Graphen.}, label={lst:creation_dijkstra_graph}]
while (unvisited.length) {
    unvisited.sort((a, b) => a.dist - b.dist);
    const u = unvisited.shift();
    u.known = true;

    for (const { ldist, o } of u.edges
        .map(e => ({ ldist: e.weight, o: graph[e.target] }))
        .filter(({ o }) => !o.known)) {
        const cdist = u.dist + ldist;
        if (cdist < o.dist) {
            o.dist = cdist;
            o.pred = u;
        }
    }
}
\end{lstlisting}

Hier wird es sich zu nutze gemacht, dass Obwohl die Liste \lstinline{unvisited} nur eine Kopie von \lstinline{graph} ist, die Referenzen der einzelnen darin enthaltenen Objekte jedoch jeweils die selben sind.
So können die Elemente in \lstinline{unvisited} dort jeweils der \lstinline{dist} nach aufsteigend sortiert und verschoben werden und die Objekte in \lstinline{graph} werden hierbei mit Information gefüllt.
Das Sortieren lässt die Objekte mit aufsteigener Distanz in \lstinline{unvisited} erscheinen.
Das erste Objekt wird entsprechend aus der Liste entfernt und die \lstinline{known} Eigenschaft wird auf \lstinline{true} gesetzt.
Bei der ersten Iteration ist dies in jedem Fall \lstinline{anchor}.
Daraufhin wird für jedes Element in der \lstinline{edges} Liste des entsprechenden Punktes die Distanz mit seiner eigenen addiert.
Nach der ersten Iteration ist also davon auszugehen, dass jeder Punkt direkt mit dem \lstinline{anchor} verbunden ist.
Bei der zweiten Iteration werden alle Punkte aus \lstinline{unvisited} wieder sortiert und jeder Punkt der nun zusammen mit der Distanz dieses Punktes eine kürzere Distanz aufweist wird seinen \lstinline{dist} und entsprechend den \lstinline{pred} Wert aktualisieren.
Dadurch, dass die \lstinline{dist} jeweils potenziert wird passiert dies bis alle Punkte durchlaufen wurden.

\subsection{Nutzung des Korrelationskoeffizienten}

Der Graph erstellt für die Punktwolke einen Pfad für jeden Punkt zu dem \lstinline{anchor}.
Dieser Pfad soll jetzt dazu genutzt werden um eine Linie zu bilden.
Die Idee ist, dass wenn man die äu{\ss}ersten Punkte des Graphen nimmt um von diesen zum \lstinline{anchor} wandert, dann werden hierdurch Pfade gebildet welche keine Ausläufer haben.

\begin{lstlisting}[language=JavaScript, caption={Bestimmung der äu{\ss}ersten Knoten zur Bestimmung von Geraden durch den Korrelationskoeffizienten in der \lstinline{groupsByCorrelation} Funktion innerhalb der \lstinline{Dijkstra} Klasse.}, label={lst:dijkstra_correlation_part1}]
let ends = this.graph
    .filter((n) => !this.graph.some(g => g.pred.id === n.id))
    .sort((a, b) => b.dist - a.dist);

const winner = [];

while (ends.length) {
    const occupied = (function f(o, arr) {
        if (o.pred) arr = f(o.pred, arr);
        return [...arr, o];
    })(ends[0], []);
    winner.push(ends.shift());

    ends = ends.filter(u => {
        for (let p = u.pred; p.pred; p = p.pred)
            if (occupied.includes(p)) return false;
        return true;
    });
}
\end{lstlisting}

Hierfür werden zunächst die Knoten im Graphen gesucht, welche keinen Vorgänger haben.
Dann wird eine Liste dieser, welche als \lstinline{ends} bezeichnet wird, der \lstinline{dist} nach absteigend sortiert.
Diese Liste wird dann gefiltert, indem der Punkt der jeweils die grö{\ss}te Distanz hat andere Punkte filtert, nach dem Prädikat ob diese, oder rekursiv dessen \lstinline{pred} Eigenschaften gemeinsame Vorgänger haben.

Dieser Vorgang wird solange wiederholt, bis die \lstinline{ends} Liste leer ist, sodass nurnoch äu{\ss}ere Knoten vorgehalten werden welche keine gemeinsamen Vorgänger zum \lstinline{anchor} haben.

Diese als \lstinline{winner} bezeichneten Knoten werden dann über ihre Vorgänger iterieren um zu prüfen ob sich mit diesen eine Gerade bilden lässt.

\begin{lstlisting}[language=JavaScript, caption={Bestimmung der äu{\ss}ersten Knoten zur Bestimmung von Geraden durch den Korrelationskoeffizienten in der \lstinline{groupsByCorrelation} Funktion innerhalb der \lstinline{Dijkstra} Klasse.}, label={lst:dijkstra_correlation_part2}]
let lines = [];
for (const win of winner) {
    let group = [];
    for (let u = win; u.pred; u = u.pred) {
        const correlation = PointCloud.correlation(
            [...group, this.points[u.id]]);
        if (Math.abs(correlation) ** group.length < minCorr) {
            if (group.length > this.points.length * minPercent) {
                lines.push(Line.fromRegressionLine(group, g));
            }
            group = [];
        }
        group.push(this.points[u.id]);
    }
    lines.push(Line.fromRegressionLine(group, g));
}
\end{lstlisting}

Die Punkte werden auf ihre nähe zu einer Regressionsgeraden über den Korrelationskoeffizienten geprüft.
Der Korrelationskoeffizient berechnet sich durch~\cite{Papula2014}

\begin{equation}
    r = \left(\left(\sum_{i=1}^n x_i y_i\right) - n \bar{x} \bar{y}\right) \div \sqrt{\left(\sum_{i=1}^n x_i^2 - n\bar{x}^2\right)\left(\sum_{i=1}^n y_i^2 - n \bar{y}^2\right)}
    \label{eq:korrelationskoeffizient}
\end{equation}

und dessen Berechnung ist als statische Funktion auf der \lstinline{PointCloud} definiert.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{gfx/correlation_edit.png}
    \caption[Versuch \lstinline{gruppe3_3.html}]{Versuch \lstinline{gruppe3_3.html}. Das linke Bild zeigt den Mechanismus. Das mittlere Bild zeigt die Regressionsgeraden welche durch die vorgeschlagene Methode meistens ermittelt werden. Das rechte Bild zeigt einen entsprechenden Fehler, welcher der falschen Zuordnung der Pfade im Graphen zugrunde liegt.}
    \label{fig:gruppe3_3}
\end{figure}

In Listing~\ref{lst:dijkstra_correlation_part2} wird für jeden Eintrag aus \lstinline{winner} der Vorgänger gewählt und diese werden einer Liste \lstinline{group} hinzugefügt.
Für diese Gruppe an Punkten wird dann der Korrelationskoeffizient bemessen.
Ist dieser niederiger als der Schwellenwert wird noch geprüft ob eine Mindestanzahl an Punkten erreicht ist, damit aus diesen dann die Regressionsgerade gebildet werden kann\footnote{Der Standardwert für den Schwellenwert der Regressionsgeraden liegt bei $0.6$ und die Mindestanzahl an Punkten liegt bei $10\%$ der Gesamtzahl der Punkte des Graphen.}.

Diese Geraden werden dann vorgehalten und könnten für weitere Analysen genutzt werden.

\section{Rekonstruktion eines Mechanismus durch die Relativpole}

Der letzte Schritt der nach einer erfolgreichen Ermittlung der Pole durchgeführt werden muss ist die Rekonstruktion des zugrundeliegenden Mechanismus.
Das ist nach den Regeln der Relativkinematik möglich~\cite[S.~66]{Kerle2016}.

Hierfür sollen die Momentanpole von allen bewegten Gliedebenen ermittelt werden.
Die Bewegung eines Gliedes um ein anderes Glied geschieht stets um einen gemeinsamen Pol.
Daraus lässt sich ableiten, dass die Anzahl dieser Pole durch~\cite{Goessner2017}

\begin{equation}
    k = \frac{n}{2}(n-1)
    \label{eq:anzahl_pole}
\end{equation}

ermittelt werden kann.

Nach dem Satz von Aronhold-Kennedy~\cite{Goessner2017, Kerle2016}, welcher auch als 3-Polsatz bezeichnet wird, befinden sich für drei bewegte Gliedebenen jeweils drei Relativpole auf einer Geraden.
Das bedeuted, dass für zwei ausgewählte bereits ermittelte Pole ein dritter ermittelt werden kann, indem auf Schnittpunkte mit anderen bewegten Gliedebenen gesucht wird.
Für ein 4-Gelenk werden entsprechend sechs Relativpole gesucht.
Die Anzahl der Gliedebenen sei hier bekannt durch die Menge welche durch die Algorithmen dieses Kapitels bestimmt wird.
Bei einem 4-Gelenk sind dies drei Gliedebenen, von denen zwei Absolutpole darstellen.
Aus den Schnittpunkten der bekannten Gliedebenen lassen sich entsprechend zwei weitere Pole bestimmen, welche in diesem Fall die Gelenke darstellen.
Der letzte Pol wird ermittelt durch die Gliedebene der Koppel und der gedachten Geraden durch die Absolutpole.
Der dadurch ermittelte Pol stellt jedoch offensichtlich kein Gelenk dar, sodass die anderen beiden ermittelten Pole als solche deklariert werden.
Die Absolutpole werden entsprechend als Gelenke zum Gestell aufgefasst.
