<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <script src="g2.full.js"></script>
    <script src="gnd.js"></script>
    <script src="mec2.min.js"></script>
    <script src="smallest_enclosing_circle.js"></script>
    <script src="compare_images.js"></script>
    <script src="simulation.js"></script>
    <script src="pendel1.js"></script>

    <b>pendel1_3.html</b>
    <p>Test mit Pendel durch kleinsten ummantelnden Kreis, wenn das Glied sich um weit weniger als 180째 dreht.
        Hier wird zus채tzlich der Pfad des Mittelpunktes des Kreises ermittelt. Wie man sieht, bewegt dieser sich
        zun채chst die ersten 90째 auf einer geraden Linie und beginnt dann einen Kreisbogen bis zum Mittelpunkt zu
        vollziehen.
    </p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' }, ori: { type: 'drive', Dt: 1, Dw: - Math.PI } }
            ]
        };

        let trail = [];
        reset = () => {
            ply = [];
            trail = [];
        }

        const fn = (result) => {
            g2().clr().exe(ctx2);

            const cir = addPointForCircle(result);
            cir && trail.push(cir);

            gnd.getChart().exe(ctx3);

            g2().ply({ pts: trail })
                .cir({ ...gnd.past[gnd.past.length - 1] })
                .exe(ctx2);

            if (gnd.confident) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                const g = g2();

                if (nod) {
                    g.lin({ x1: gnd.x, y1: gnd.y, x2: nod.x, y2: nod.y })
                        .nod(nod);

                }
                g.gnd({ ...gnd }).exe(ctx2);
            }
        };

        simulation(model, fn);
    </script>
</body>

</html>