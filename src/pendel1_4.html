<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <b id="title"></b>
    <script src="third_party/g2.full.js"></script>
    <script src="gnd.js"></script>
    <script src="third_party/mec2.min.js"></script>
    <script src="smallest_enclosing_circle.js"></script>
    <script src="compare_images.js"></script>
    <script src="simulation.js"></script>
    <script src="pendel1.js"></script>

    <p>Eine Beobachtung ist in jedem Fall, dass der Drehpunkt auf der Orthogonalen zu der beobachteten Linie mit dem
        ersten Mittelpunkt als Ursprung liegt.

        Der Abstand der Mittelpunktes zum Drehpunkt entspricht dem Radius des Teilkreises der vom Pfad des Mittelpunktes
        gezeichnet wird, allerdings nur wenn die Bedeckung 0 ist.
    </p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        let trail = [];
        reset = () => {
            ply = [];
            trail = [];
        }

        const fn = (result) => {
            g2().clr().exe(ctx2);

            const cir = addPointsForCircle(result);
            cir && trail.push(cir);


            const limit = 20;
            if (trail.length > limit) {
                const t0 = trail[0];

                const m =
                    (trail[limit - 1].y - t0.y) /
                    (trail[limit - 1].x - t0.x);
                const b = t0.y - t0.x * m;
                const w = Math.atan(- 1 / m);

                const c = t0.y + t0.x / m;

                const p2 = {
                    x: t0.x - t0.r * Math.cos(w),
                    y: t0.y - t0.r * Math.sin(w)
                }

                g2().lin({
                    p1: { x: 0, y: b },
                    p2: { x: cnv1.width, y: m * cnv1.width + b },
                }).lin({
                    p1: { x: 0, y: c },
                    p2: { x: cnv1.width, y: - 1 / m * cnv1.width + c },
                    lw: 2,
                    ls: 'green',
                }).lin({
                    p1: t0,
                    p2,
                    lw: 3,
                    ls: 'blue'
                }).exe(ctx2);

                ply.length && gnd.add(p2);
                gnd.x = p2.x;
                gnd.y = p2.y;
                gnd.confident = true;
                gnd.getChart().exe(ctx3);
            }

            g2().ply({ pts: trail })
                .cir({ ...gnd.past[gnd.past.length - 1] })
                .beg({ cartesian: true })
                .end()
                .exe(ctx2);

            if (gnd.confident) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                g2().lin({ x1: gnd.x, y1: gnd.y, x2: nod.x, y2: nod.y })
                    .gnd({ ...gnd })
                    .nod(nod)
                    .exe(ctx2);
                gnd2.innerHTML = `Vermutet: x: ${gnd.x}, y: ${cnv1.height - gnd.y}`;
            }
        };

        simulation(model, () => step_compare_images(fn));
    </script>
</body>

</html>