<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <script src="https://goessner.github.io/g2/g2.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="./getDirectionalColor.js"></script>
    <script src="./gnd.js"></script>
    <script src="./compare_images.js"></script>
    <script src="../src/simulation.js"></script>
    <b>pendel3_3.html</b>
    <p>Method of least square regression
    </p>
    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 149.9, y: 100, base: true },
                { id: 'A1', x: 150, y: 150 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        let gnd = new Gnd();
        let nod; // EndstÃ¼ck des Pendels

        const ws = []; // Sammlung der Winkelbewegungen

        function removeOverlaps(boxes) {
            const mostAccurate = [];
            while (boxes.length) {
                const max = boxes.pop();
                mostAccurate.push(max);
                boxes = boxes.filter(
                    (rec) =>
                        Math.abs(rec.x - max.x) >= 10 ||
                        Math.abs(rec.y - max.y) >= 10
                );
            }
            return mostAccurate;
        }

        const fn = (result) => {
            const filtered = removeOverlaps(result);

            let max = 0;
            let p1;
            let p2;

            result.forEach(r => {
                result.forEach(s => {
                    const hy = Math.hypot(r.y - s.y, r.x - s.x);
                    if (hy > max) {
                        max = hy;
                        if (r.x > s.x) {
                            p1 = s;
                            p2 = r;
                        } else {
                            p1 = r;
                            p2 = s;
                        }
                    };
                });
            });

            if (!p1 || !p2) {
                return;
            }

            const tmp = (p2.y - p1.y) / (p2.x - p1.x);
            const swap = Math.abs(Math.atan(tmp)) < Math.PI / 4;

            const n = filtered.length;
            if (!n) return;
            const sxy = filtered.map(e => e.x * e.y).reduce((pre, cur) => cur + pre);
            const sx = filtered.map(e => e.x).reduce((pre, cur) => cur + pre);
            const sy = filtered.map(e => e.y).reduce((pre, cur) => cur + pre);

            const s2 = filtered.map(e => (swap ? e.x : e.y) ** 2).reduce((pre, cur) => cur + pre);

            const counter = (n * sxy - sx * sy);
            const denominator = (n * s2 - (swap ? sx : sy) ** 2);

            let m = swap ? counter / denominator : denominator / counter;
            let b = (sy - m * sx) / n;

            g2().clr().exe(ctx2);
            filtered.forEach(e => {
                g2().cir({ x: e.x, y: e.y, r: 0.5 }).exe(ctx2);
            });

            g2().lin({ x1: 0, y1: b, x2: 300, y2: m * 300 + b }).exe(ctx2)
        };

        simulation(model, fn);
    </script>
</body>

</html>