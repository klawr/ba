<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <p>Hier wird eine Linie definiert durch die am weitesten voneinander entfernten Pixel bei denen eine Ver채nderung
        gemessen wurde.
        Alle Schnittpunkte dieser Linien bestimmen dann einen Schwerpunkt, von dem ausgegangen wird, dass dieser in der
        n채he des Drehpunktes sein muss.
    </p>
    <input id="btn" type="button" value="Start/Stop"></input>
    <div id="gnd1" style="display:inline"></div>
    <div id="gnd2" style="display:inline"></div>
    <br>
    <br>

    <canvas id="cnv1" width="320" height="180"></canvas>
    <canvas id="cnv2" width="320" height="180"></canvas>
    <canvas id="cnv3" width="320" height="180"></canvas>
    <script src="https://goessner.github.io/g2/g2.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../src/compare_images.js"></script>

    <script>
        const cnv1 = document.getElementById('cnv1');
        const ctx1 = cnv1.getContext('2d');

        const cnv2 = document.getElementById('cnv2');
        const ctx2 = cnv2.getContext('2d');

        const cnv3 = document.getElementById('cnv3');
        const ctx3 = cnv3.getContext('2d');

        const g = g2().clr().view({ cartesian: true });         // a g2 graphics-object
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        const base = model.nodes.find(e => e.id === 'A0');
        gnd1.innerHTML = `Tats채chlich: x: ${base.x}, y: ${base.y}`;

        const data = [];
        const lines = [];
        let gnd = { x: 0, y: 0, confident: false, past: [] }; // Ground
        let nod; // Endst체ck des Pendels

        // simulation
        const simulate = () => {
            model.tick(1 / 60); // solve model with fixed stepping
            g.exe(ctx1);         // render its pose on the canvas

            const image1 = ctx1.getImageData(0, 0, cnv1.width, cnv1.height).data;

            window.setTimeout(() => {
                const image2 = ctx1.getImageData(0, 0, cnv1.width, cnv1.height).data;
                const result = compare_images(image1, image2, cnv1.width, cnv1.height);

                g2().clr().exe(ctx2);

                let max = 0;
                let p1;
                let p2;

                result.forEach(r => {
                    result.forEach(s => {
                        const hy = Math.hypot(r.y - s.y, r.x - s.x);
                        if (hy > max) {
                            max = hy;
                            // p1 = s;
                            // p2 = r;
                            if (r.x > s.x) {
                                p1 = s;
                                p2 = r;
                            } else {
                                p1 = r;
                                p2 = s;
                            }
                        };
                    });
                });

                if (!p1 || !p2) {
                    return;
                }


                const m = (p2.y - p1.y) / (p2.x - p1.x);
                const b = p1.y - m * p1.x;

                if (!gnd.confident) {
                    lines.push({ m, b });

                    if (lines.length > 1) {
                        const pts = [];
                        for (let i = 0; i < lines.length; ++i) {
                            for (let j = 1; j < lines.length; ++j) {
                                const m1 = lines[i].m;
                                const b1 = lines[i].b;
                                const m2 = lines[j].m;
                                const b2 = lines[j].b;

                                const x = (b1 - b2) / (m2 - m1);
                                const y = m1 * x + b1;

                                if (Number.isFinite(x) && Number.isFinite(y)) pts.push({ x, y });
                            }
                        }
                        const pre_gnd = pts.reduce((pre, cur) => ({
                            x: pre.x + cur.x,
                            y: pre.y + cur.y
                        }), { x: 0, y: 0 });

                        pre_gnd.x /= pts.length;
                        pre_gnd.y /= pts.length;

                        gnd2.innerHTML = `Erstmal: x: ${pre_gnd.x}, y: ${cnv1.height - pre_gnd.y}`;

                        g2().gnd(pre_gnd).exe(ctx2);

                        if (gnd.past.push(pre_gnd) > 10) {
                            gnd.past.shift();
                        };

                        let acc = 0;
                        for (let i = 1; i < gnd.past.length; ++i) {
                            const pre = gnd.past[i - 1];
                            const cur = gnd.past[i];
                            acc += Math.hypot(cur.x - pre.x, cur.y - pre.y);
                        }

                        if (gnd.past.length === 10 && acc < 0.5) {
                            gnd.confident = true;
                            gnd.x = gnd.past[gnd.past.length - 1].x;
                            gnd.y = gnd.past[gnd.past.length - 1].y;
                        }
                    }
                    g2().lin({ x1: 0, y1: b, x2: cnv1.width, y2: m * cnv1.width + b }).exe(ctx2);

                } else {
                    for (let i = 0, max = 0; i < result.length; ++i) {
                        const r = result[i];
                        if (r.x === 0 && r.y === 0) {
                            continue;
                        }
                        const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                        if (hy > max) {
                            nod = r;
                        }
                    }

                    gnd2.innerHTML = `Vermutet: x: ${gnd.x}, y: ${cnv1.height - gnd.y}`;
                    g2().lin({ p1: gnd, p2: nod })
                        .gnd(gnd)
                        .nod(nod)
                        .exe(ctx2);

                }


                const align = (a) => (Math.PI + a) % Math.PI

                data.push(data.length / 2 * 1 / 60,
                    align(-model.constraints[0].w) - align(Math.atan(m)));

                const chart = {
                    x: 20, y: 20, b: 280, h: 150,
                    funcs: [{ data }],
                    xaxis: {},
                    yaxis: {},
                }

                g2().clr().view({ cartesian: true }).chart(chart).exe(ctx3);
            }, 1000 / 60);

            if (running) {
                requestAnimationFrame(simulate);  // keep calling back
            }
        };

        mec.model.extend(model);                    // extend the model
        model.init();                               // initialize it
        model.draw(g);                              // append model-graphics to graphics-obj

        let running = false;
        const btn = document.getElementById('btn');
        btn.addEventListener('click', () => {
            running = !running;
            running && simulate();  // kick-off the simulation
        });
        simulate();                                 // kick-off the simulation
    </script>
</body>

</html>