<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <b>pendel2_1.html</b>
    <p>Hier wird eine Linie definiert durch die am weitesten voneinander entfernten Pixel bei denen eine Veränderung
        gemessen wurde.
        Alle Schnittpunkte dieser Linien bestimmen dann einen Schwerpunkt, von dem ausgegangen wird, dass dieser in der
        nähe des Drehpunktes sein muss.
    </p>
    
    <script src="g2.full.js"></script>
    <script src="gnd.js"></script>
    <script src="mec2.min.js"></script>
    <script src="compare_images.js"></script>
    <script src="simulation.js"></script>
    <script src="getMaxDist.js"></script>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        const data = [];
        const lines = [];
        let nod; // Endstück des Pendels

        const fn = (result) => {
            g2().clr().exe(ctx2);

            const [p1, p2] = getMaxDist(result);

            

            if (!p1 || !p2) {
                return;
            }

            const m = (p2.y - p1.y) / (p2.x - p1.x);
            const b = p1.y - m * p1.x;

            if (!gnd.confident) {
                result.forEach(e => g2().cir({...e, r: 1}).exe(ctx2));
                g2().cir({...p1, r: 4, fs: 'green'})
                    .cir({...p2, r: 4, fs: 'red'})
                    .exe(ctx2);

                lines.push({ m, b });

                if (lines.length > 1) {
                    const pts = [];
                    for (let i = 0; i < lines.length; ++i) {
                        for (let j = 1; j < lines.length; ++j) {
                            const m1 = lines[i].m;
                            const b1 = lines[i].b;
                            const m2 = lines[j].m;
                            const b2 = lines[j].b;

                            const x = (b1 - b2) / (m2 - m1);
                            const y = m1 * x + b1;

                            if (Number.isFinite(x) && Number.isFinite(y)) {
                                pts.push({ x, y });
                            }
                        }
                    }
                    const pre_gnd = pts.reduce((pre, cur) => ({
                        x: pre.x + cur.x,
                        y: pre.y + cur.y
                    }), { x: 0, y: 0 });

                    pre_gnd.x /= pts.length;
                    pre_gnd.y /= pts.length;

                    gnd2.innerHTML = `Erstmal: x: ${pre_gnd.x}, y: ${cnv1.height - pre_gnd.y}`;

                    g2().cir({ ...pre_gnd, r: 5 }).exe(ctx2);

                    gnd.add(pre_gnd, 0.5);
                    gnd.getChart().exe(ctx3);
                }

                g2().lin({ x1: 0, y1: b, x2: cnv1.width, y2: m * cnv1.width + b }).exe(ctx2);
            } else {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                g2().lin({ p1: gnd, p2: nod })
                    .gnd({ ...gnd })
                    .nod(nod)
                    .exe(ctx2);
            }
        };

        simulation(model, () => step_compare_images(fn));
    </script>
</body>

</html>