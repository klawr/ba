<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <script src="g2.full.js"></script>
    <script src="mec2.min.js"></script>
    <script src="getDirectionalColor.js"></script>
    <script src="gnd.js"></script>
    <script src="compare_images.js"></script>
    <script src="simulation.js"></script>
    <b>pendel2_5.html</b>
    <p>Durch die Lösung der Methode der kleinsten Quadrate entsteht wie in den vorherigen Beispielen sichtbar ein Fehler sobald die Linie eher vertikal wird. Indem die Achsen, bzw. die Lösung der Methode gespiegelt wird wenn die Linie mehr vertikal als horizonzal ist soll dieses Problem behoben werden.
    </p>
    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 149.9, y: 100, base: true },
                { id: 'A1', x: 150, y: 150 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        let gnd = new Gnd();
        let nod; // Endstück des Pendels

        const lines = []; // Sammlung der Winkelbewegungen

        function removeOverlaps(boxes) {
            const mostAccurate = [];
            while (boxes.length) {
                const max = boxes.pop();
                mostAccurate.push(max);
                boxes = boxes.filter(
                    (rec) =>
                        Math.abs(rec.x - max.x) >= 5 ||
                        Math.abs(rec.y - max.y) >= 5
                );
            }
            return mostAccurate;
        }

        const fn = (result) => {
            g2().clr().exe(ctx2);

            const filtered = removeOverlaps(result);

            let max = 0;
            let p1;
            let p2;

            result.forEach(r => {
                result.forEach(s => {
                    const hy = Math.hypot(r.y - s.y, r.x - s.x);
                    if (hy > max) {
                        max = hy;
                        if (r.x > s.x) {
                            p1 = s;
                            p2 = r;
                        } else {
                            p1 = r;
                            p2 = s;
                        }
                    };
                });
            });

            if (!p1 || !p2) {
                return;
            }

            const tmp = (p2.y - p1.y) / (p2.x - p1.x);
            const swap = Math.abs(Math.atan(tmp)) < Math.PI / 4;

            const n = filtered.length;
            if (!n) return;
            const sxy = filtered.map(e => e.x * e.y).reduce((pre, cur) => cur + pre);
            const sx = filtered.map(e => e.x).reduce((pre, cur) => cur + pre);
            const sy = filtered.map(e => e.y).reduce((pre, cur) => cur + pre);

            const s2 = filtered.map(e => (swap ? e.x : e.y) ** 2).reduce((pre, cur) => cur + pre);

            const counter = (n * sxy - sx * sy);
            const denominator = (n * s2 - (swap ? sx : sy) ** 2);

            let m = swap ? counter / denominator : denominator / counter;
            let b = (sy - m * sx) / n;

            if (!gnd.confident) {
                lines.push({ m, b });

                if (lines.length > 1) {
                    const pts = [];
                    for (let i = 0; i < lines.length; ++i) {
                        for (let j = 1; j < lines.length; ++j) {
                            const m1 = lines[i].m;
                            const b1 = lines[i].b;
                            const m2 = lines[j].m;
                            const b2 = lines[j].b;

                            const x = (b1 - b2) / (m2 - m1);
                            const y = m1 * x + b1;

                            if (Number.isFinite(x) && Number.isFinite(y)) {
                                pts.push({ x, y });
                            }
                        }
                    }
                    const pre_gnd = pts.reduce((pre, cur) => ({
                        x: pre.x + cur.x,
                        y: pre.y + cur.y
                    }), { x: 0, y: 0 });

                    pre_gnd.x /= pts.length;
                    pre_gnd.y /= pts.length;

                    gnd2.innerHTML = `Erstmal: x: ${pre_gnd.x}, y: ${cnv1.height - pre_gnd.y}`;

                    g2().cir({ ...pre_gnd, r: 5 }).exe(ctx2);

                    gnd.add(pre_gnd, 0.5);
                    gnd.getChart().exe(ctx3);
                }

                filtered.forEach(e => {
                    g2().cir({ x: e.x, y: e.y, r: 0.5 }).exe(ctx2);
                });

                g2().lin({ x1: 0, y1: b, x2: 300, y2: m * 300 + b }).exe(ctx2);

                g2().lin({ x1: 0, y1: b, x2: cnv1.width, y2: m * cnv1.width + b }).exe(ctx2);
            } else {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                gnd2.innerHTML = `Vermutet: x: ${gnd.x}, y: ${cnv1.height - gnd.y}`;
                g2().lin({ p1: gnd, p2: nod })
                    .gnd({ ...gnd })
                    .nod(nod)
                    .exe(ctx2);
            }
        };

        simulation(model, fn);
    </script>
</body>

</html>