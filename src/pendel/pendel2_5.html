<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <b id="title"></b>
    <script src="../third_party/g2.full.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../scripts/gnd.js"></script>
    <script src="../scripts/regressionLine.js"></script>
    <script src="../scripts/removeOverlaps.js"></script>
    <script src="../scripts/compareImages.js"></script>
    <script src="../scripts/simulation.js"></script>
    <script src="pendel2.js"></script>

    <p>Durch die Lösung der Methode der kleinsten Quadrate entsteht wie in den vorherigen Beispielen sichtbar ein Fehler
        sobald die Linie eher vertikal wird. Indem die Achsen, bzw. die Lösung der Methode gespiegelt wird wenn die
        Linie mehr vertikal als horizonzal ist soll dieses Problem behoben werden.
    </p>
    <script>
        globalTestVariables.model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 149.9, y: 100, base: true },
                { id: 'A1', x: 150, y: 150 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        const fn = (result) => {
            const { ctx2, ctx3, gnd } = globalTestVariables;
            const gpv = globalPendel2Variables;

            const g = g2().clr();

            const filtered = removeOverlaps(result);

            if (!filtered.length) return;

            const { m, b } = regressionLine(filtered);

            if (!gnd.confident) {
                gpv.lines.push({ m, b });

                if (gpv.lines.length > 1) {
                    const pts = [];
                    for (let i = 0; i < gpv.lines.length; ++i) {
                        for (let j = 1; j < gpv.lines.length; ++j) {
                            const m1 = gpv.lines[i].m;
                            const b1 = gpv.lines[i].b;
                            const m2 = gpv.lines[j].m;
                            const b2 = gpv.lines[j].b;

                            const x = (b1 - b2) / (m2 - m1);
                            const y = m1 * x + b1;

                            if (Number.isFinite(x) && Number.isFinite(y)) {
                                pts.push({ x, y });
                            }
                        }
                    }
                    const pre_gnd = pts.reduce((pre, cur) => ({
                        x: pre.x + cur.x,
                        y: pre.y + cur.y
                    }), { x: 0, y: 0 });

                    pre_gnd.x /= pts.length;
                    pre_gnd.y /= pts.length;

                    gnd2.innerHTML = `Erstmal: x: ${pre_gnd.x}, y: ${cnv1.height - pre_gnd.y}`;

                    g.cir({ ...pre_gnd, r: 5 });

                    gnd.add(pre_gnd, 0.5);
                    gnd.getChart().exe(ctx3);
                }

                filtered.forEach(e => {
                    g.cir({ x: e.x, y: e.y, r: 0.5 });
                });

                g.lin({ x1: 0, y1: b, x2: 300, y2: m * 300 + b });

                g.lin({ x1: 0, y1: b, x2: cnv1.width, y2: m * cnv1.width + b });
            } else {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        gpv.nod = r;
                    }
                }

                g.lin({ p1: gnd, p2: gpv.nod })
                    .gnd({ ...gnd })
                    .nod(gpv.nod);
            }

            g.exe(ctx2);
        };

        register(() => stepCompareImages(fn));
    </script>
</body>

</html>