<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <b id="title"></b>
    <script src="../third_party/g2.full.js"></script>
    <script src="../scripts/gnd.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../scripts/smallest_enclosing_circle.js"></script>
    <script src="../scripts/compare_images.js"></script>
    <script src="../scripts/simulation.js"></script>
    <script src="pendel1.js"></script>

    <p>Test mit Pendel durch kleinsten ummantelnden Kreis, wenn das Glied sich um weit weniger als 180° dreht.
        Hier wird zusätzlich der Pfad des Mittelpunktes des Kreises ermittelt. Wie man sieht, bewegt dieser sich
        zunächst die ersten 90° auf einer geraden Linie und beginnt dann einen Kreisbogen bis zum Mittelpunkt zu vollziehen, wenn die Bedeckung nicht aktiv ist.
        Die gerade Linie verkürzt sich je größer der Radius gemacht wird, bis der Pfad des Mittelpunkt des ermittelten Kreises selbst einen Halbkreis vollzieht.
        Dieser Halbkreis ist konstant.
        Im Nachfolgenden wird untersucht ob hierraus Information gezogen werden kann.
    </p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' }, ori: { type: 'drive', Dt: 1, Dw: - Math.PI } }
            ]
        };

        let trail = [];
        reset = () => {
            ply = [];
            trail = [];
        }

        const fn = (result) => {
            g2().clr().exe(ctx2);

            const cir = addPointsForCircle(result);
            cir && trail.push(cir);

            gnd.getChart().exe(ctx3);

            g2().ply({ pts: trail })
                .cir({ ...gnd.past[gnd.past.length - 1] })
                .exe(ctx2);

            if (gnd.confident) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                const g = g2();

                if (nod) {
                    g.lin({ x1: gnd.x, y1: gnd.y, x2: nod.x, y2: nod.y })
                        .nod(nod);

                }
                g.gnd({ ...gnd }).exe(ctx2);
            }
        };

        register(model, () => step_compare_images(fn));
    </script>
</body>

</html>