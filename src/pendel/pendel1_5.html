<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <b id="title"></b>
    <script src="../third_party/g2.full.js"></script>
    <script src="../scripts/gnd.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../scripts/smallest_enclosing_circle.js"></script>
    <script src="../scripts/compare_images.js"></script>
    <script src="../scripts/simulation.js"></script>
    <script src="pendel1.js"></script>

    <p>Werden die Punkte die gemessen wurden nach dem Limit rückwärts abgespielt, dann ergeben sich 2 Linien dessen
        Schnittpunkt den Drehpunkt ergeben sollte.
    Die Linie ist tatsächlich sehr treffend, der entsprechende Winkel ist allerdings inkorrekt, da sowohl das Pendel vor, als auch das im Bild danach betrachtet wird. Dieser Fehler verschwindet jedoch, sobald man eine unbeschleunigte Bewegung nimmt.</p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' }, ori: { type: 'drive', Dt: 1, Dw: - Math.PI } }
            ]
        };

        const fn = (result) => {
            const { trail, ply, nod } = global_pendel1_variables;
            const { ctx2, ctx3, gnd } = global_test_variables;

            const g = g2().clr();

            // const cir = addPointsForCircle(result);
            if (!gnd.confident) {
                result.length && ply.push(result);
                const [cir] = makeCircle(ply.flat(), []);
                ply.length && gnd.add(cir);
                cir && trail.push(cir);
            }
            ply.length && ply[0].forEach(e => g.cir({ ...e, r: 1 }));

            const limit = 20;
            if (trail.length > limit) {
                const tl = trail[limit - 1];
                const t0 = trail[0];

                ply[limit - 1].forEach(e => g.cir({ ...e, r: 1 }));
                const p1 = makeCircle(ply[limit - 1], []);

                g.lin({ p1: p1, p2: tl });

                const m1 =
                    (tl.y - t0.y) /
                    (tl.x - t0.x);
                const b1 = t0.y - t0.x * m1;
                const w1 = Math.atan(- 1 / m1);

                const b1o = t0.y + t0.x / m1;

                const m2 =
                    (tl.y - p1.y) /
                    (tl.x - p1.x);
                const b2 = p1.y + p1.x / m2;
                const w2 = Math.atan(-1 / m2);

                const b2o = p1.y + p1.x / m2;

                const x = (b1o - b2o) / (1 / m1 - 1 / m2);
                const p2 = { x, y: - x / m1 + b1o };

                g.lin({
                    p1: { x: 0, y: b1 },
                    p2: { x: cnv1.width, y: m1 * cnv1.width + b1 },
                }).lin({
                    p1: { x: 0, y: b1o },
                    p2: { x: cnv1.width, y: - 1 / m1 * cnv1.width + b1o },
                    lw: 2,
                    ls: 'green',
                }).lin({
                    p1: { x: 0, y: b2o },
                    p2: { x: cnv1.width, y: -1 / m2 * cnv1.width + b2o },
                    lw: 2,
                    ls: 'red'
                });

                ply.length && gnd.add(p2);
                gnd.x = p2.x;
                gnd.y = p2.y;
                gnd.confident = true;
                gnd.getChart().exe(ctx3);
            }

            g.ply({ pts: trail })
                .cir({ ...gnd.past[gnd.past.length - 1] })
                .beg({ cartesian: true })
                .end();

            if (gnd.confident) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                g.lin({ x1: gnd.x, y1: gnd.y, x2: nod.x, y2: nod.y })
                    .gnd({ ...gnd })
                    .nod(nod)
                gnd2.innerHTML = `Vermutet: x: ${gnd.x}, y: ${cnv1.height - gnd.y}`;
            }

            g.exe(ctx2);
        };

        register(model, () => step_compare_images(fn));
    </script>
</body>

</html>