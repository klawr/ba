<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <b id="title"></b>
    <p>Hier wird eine Linie definiert durch den Schwerpunkt der 5 am weitesten voneinander entfernten Pixel bei denen eine Veränderung
        gemessen wurde.
        Alle Schnittpunkte dieser Linien bestimmen dann einen Schwerpunkt, von dem ausgegangen wird, dass dieser in der
        nähe des Drehpunktes sein muss.
    </p>

    <script src="../third_party/g2.full.js"></script>
    <script src="../scripts/gnd.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../scripts/compare_images.js"></script>
    <script src="../scripts/simulation.js"></script>
    <script src="../scripts/getMaxDist.js"></script>
    <script src="pendel2.js"></script>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        const fn = (result) => {
            const { ctx2, ctx3, gnd } = global_test_variables;
            const { data, lines } = global_pendel2_variables;
            const gpv = global_pendel2_variables;

            g2().clr().exe(ctx2);

            const [p1, p2] = getMaxDistCoG(result, 5);

            if (!p1 || !p2) {
                return;
            }

            const m = (p2.y - p1.y) / (p2.x - p1.x);
            const b = p1.y - m * p1.x;

            if (!gnd.confident) {
                result.forEach(e => g2().cir({ ...e, r: 1 }).exe(ctx2));
                g2().cir({ ...p1, r: 4, fs: 'green' })
                    .cir({ ...p2, r: 4, fs: 'red' })
                    .exe(ctx2);

                lines.push({ m, b });

                if (lines.length > 1) {
                    const pts = [];
                    for (let i = 0; i < lines.length; ++i) {
                        for (let j = 1; j < lines.length; ++j) {
                            const m1 = lines[i].m;
                            const b1 = lines[i].b;
                            const m2 = lines[j].m;
                            const b2 = lines[j].b;

                            const x = (b1 - b2) / (m2 - m1);
                            const y = m1 * x + b1;

                            if (Number.isFinite(x) && Number.isFinite(y)) {
                                pts.push({ x, y });
                            }
                        }
                    }
                    const pre_gnd = pts.reduce((pre, cur) => ({
                        x: pre.x + cur.x,
                        y: pre.y + cur.y
                    }), { x: 0, y: 0 });

                    pre_gnd.x /= pts.length;
                    pre_gnd.y /= pts.length;

                    gnd2.innerHTML = `Erstmal: x: ${pre_gnd.x}, y: ${cnv1.height - pre_gnd.y}`;

                    g2().cir({ ...pre_gnd, r: 5 }).exe(ctx2);

                    gnd.add(pre_gnd, 0.5);
                    gnd.getChart().exe(ctx3);
                }

                g2().lin({ x1: 0, y1: b, x2: cnv1.width, y2: m * cnv1.width + b }).exe(ctx2);
            } else {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        gpv.nod = r;
                    }
                }

                g2().lin({ p1: gnd, p2: gpv.nod })
                    .gnd({ ...gnd })
                    .nod(gpv.nod)
                    .exe(ctx2);
            }
        };

        register(model, () => step_compare_images(fn));
    </script>
</body>

</html>