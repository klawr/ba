<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <a id="title"></a>
    <p>Hier wird eine Linie definiert durch die am weitesten voneinander entfernten Pixel bei denen eine Veränderung
        gemessen wurde.
        Alle Schnittpunkte dieser Linien bestimmen dann einen Schwerpunkt, von dem ausgegangen wird, dass dieser in der
        nähe des Drehpunktes sein muss.
    </p>

    <script src="../third_party/g2.full.js"></script>
    <script src="../scripts/data.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../scripts/compareImages.js"></script>
    <script src="../scripts/simulation.js"></script>
    <script src="../scripts/getMaxDist.js"></script>
    <script src="pendel2.js"></script>

    <script>
        globalTestVariables.model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        const { data } = globalPendel2Variables;

        const fn = (result) => {
            const { lines } = globalPendel2Variables;
            const gpv = globalPendel2Variables;
            const { ctx2, ctx3, txt2 } = globalTestVariables;

            const g = g2().clr();

            const [p1, p2] = getMaxDistCoG(result, 5, g);

            if (!p1 || !p2) {
                return;
            }

            const m = (p2.y - p1.y) / (p2.x - p1.x);
            const b = p1.y - m * p1.x;

            result.forEach(e => g.cir({ ...e, r: 1 }));

            lines.push({ m, b });

            if (lines.length > 1) {
                for (let i = 0; i < lines.length; ++i) {
                    for (let j = 1; j < lines.length; ++j) {
                        const m1 = lines[i].m;
                        const b1 = lines[i].b;
                        const m2 = lines[j].m;
                        const b2 = lines[j].b;

                        const x = (b1 - b2) / (m2 - m1);
                        const y = m1 * x + b1;

                        if (Number.isFinite(x) && Number.isFinite(y)) {
                            data.add({ x, y });
                        }
                    }
                }
                const gnd = { x: data.muX, y: data.muY };

                txt2.innerHTML = `Erstmal: x: ${gnd.x}, y: ${cnv1.height - gnd.y}`;

                g.cir({ ...gnd, r: 5 });

                data.add(gnd);
                data.getChart().exe(ctx3);
            }

            g.lin({ x1: 0, y1: b, x2: cnv1.width, y2: m * cnv1.width + b });

            if (false && pre_gnd) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - pre_gnd.y, r.x - pre_gnd.x);

                    if (hy > max) {
                        gpv.nod = r;
                    }

                    gpv.nod && g.lin({ p1: pre_gnd, p2: gpv.nod })
                        // .gnd({ ...pre_gnd })
                        .nod(gpv.nod);
                }
            }

            g.exe(ctx2);
        };

        globalTestVariables.register(() => stepCompareImages(fn));
    </script>
</body>

</html>