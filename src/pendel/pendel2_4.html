<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <a id="title"></a>
    <script src="../third_party/g2.full.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="../scripts/data.js"></script>
    <script src="../scripts/compareImages.js"></script>
    <script src="../scripts/simulation.js"></script>

    <p>Hier soll durch die LÃ¶sung der Methode der kleinsten Quadrate die am besten passende Linie definiert werden. Durch das Entfernen von Punkten in einem bestimmten Umkreis soll die Dichte homogen gehalten werden, was diesen Fehler korrigiert.
    </p>

    <script>
        globalTestVariables.model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 149.9, y: 100, base: true },
                { id: 'A1', x: 150, y: 150 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };


        function removeOverlaps(boxes) {
            const mostAccurate = [];
            while (boxes.length) {
                const max = boxes.pop();
                mostAccurate.push(max);
                boxes = boxes.filter(
                    (rec) =>
                        Math.abs(rec.x - max.x) >= 10 ||
                        Math.abs(rec.y - max.y) >= 10
                );
            }
            return mostAccurate;
        }

        const fn = (result) => {
            const { ctx2, ctx3, gnd } = globalTestVariables;

            const filtered = removeOverlaps(result);

            let max = 0;
            let p1;
            let p2;

            const sum = filtered.reduce((pre, cur) => ({
                x: pre.x + cur.x,
                y: pre.y + cur.y,
            }), { x: 0, y: 0 });

            const X = sum.x / filtered.length;
            const Y = sum.y / filtered.length;

            let m;
            let b;

            if (!X || !Y) {
                m = Number.MAX_SAFE_INTEGER;
                b = 0;
            } else {
                const counter = filtered.reduce((pre, cur) =>
                    pre + (cur.x - X) * (cur.y - Y), 0
                );
                const denominator = filtered.reduce((pre, cur) =>
                    pre + (cur.x - X) ** 2, 0
                );

                m = counter / denominator;
                b = Y - m * X;
            }

            const g = g2().clr();
            filtered.forEach(e => {
                g.cir({ x: e.x, y: e.y, r: 0.5 });
            });

            g.lin({ x1: 0, y1: b, x2: 300, y2: m * 300 + b }).exe(ctx2)
        };

        register(() => stepCompareImages(fn));
    </script>
</body>

</html>