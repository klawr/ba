<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <script src="g2.full.js"></script>
    <script src="gnd.js"></script>
    <script src="mec2.min.js"></script>
    <script src="smallest_enclosing_circle.js"></script>
    <script src="compare_images.js"></script>
    <script src="simulation.js"></script>
    <script src="pendel1.js"></script>

    <b>pendel1_5.html</b>
    <p>Tatsächlich ist bereits direkt ersichtlich, dass der Drehpunkt ungefähr dem Radius des ersten Kreises entsprechen
        muss der
        die ersten erkannten Datenpunkte enthält. Sobald also die Linie erzeugt wird, kann auf den Drehpunkt geschlossen
        werden. Der Radius ist
        allerdings etwas zu klein, sodass ein kleiner Fehler entsteht.
    </p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        let trail = [];
        reset = () => {
            ply = [];
            trail = [];
        }

        const fn = (result) => {
            g2().clr().exe(ctx2);

            const cir = addPointsForCircle(result);
            cir && trail.push(cir);


            const limit = 30;
            if (trail.length > limit) {
                const m =
                    (trail[limit - 1].y - trail[0].y) /
                    (trail[limit - 1].x - trail[0].x);
                const b = trail[0].y - trail[0].x * m;
                const w = Math.atan(- 1 / m);

                const p2 = {
                    x: trail[0].x - trail[0].r * Math.cos(w),
                    y: trail[0].y - trail[0].r * Math.sin(w)
                }

                g2().lin({
                    p1: { x: 0, y: b },
                    p2: { x: cnv1.width, y: m * cnv1.width + b }
                }).lin({ p1: trail[0], p2, }).exe(ctx2);

                ply.length && gnd.add(p2);
                gnd.x = p2.x;
                gnd.y = p2.y;
                gnd.confident = true;
                gnd.getChart().exe(ctx3);
            }

            g2().ply({ pts: trail })
                .cir({ ...gnd.past[gnd.past.length - 1] })
                .beg({ cartesian: true })
                .end()
                .exe(ctx2);

            if (gnd.confident) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                g2().lin({ x1: gnd.x, y1: gnd.y, x2: nod.x, y2: nod.y })
                    .gnd({ ...gnd })
                    .nod(nod)
                    .exe(ctx2);
                gnd2.innerHTML = `Vermutet: x: ${gnd.x}, y: ${cnv1.height - gnd.y}`;
            }
        };

        simulation(model, fn);
    </script>
</body>

</html>