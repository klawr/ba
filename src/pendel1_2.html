<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <script src="third_party/g2.full.js"></script>
    <script src="gnd.js"></script>
    <script src="third_party/mec2.min.js"></script>
    <script src="smallest_enclosing_circle.js"></script>
    <script src="compare_images.js"></script>
    <script src="simulation.js"></script>
    <script src="pendel1.js"></script>

    <b>pendel1_2.html</b>
    <p>Test mit Pendel durch kleinsten ummantelnden Kreis, wenn das Glied sich um weit weniger als 180° dreht.
        Wie man sieht, ist das Ergebnis mit einem sehr großen Fehler behaftet.
        Das Endstück des Pendels sollte auf dem Umkreis der Kreises verlaufen, was allerdings nicht der Fall ist. Diese
        Möglichekeit der Korrektur wird jedoch hier nicht weiter untersucht.

        Die Änderung der Bedeckung ändert hier die Genauigkeit auch nicht.
    </p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 150, y: 120, base: true },
                { id: 'A1', x: 230, y: 90 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        const fn = (result) => {
            g2().clr().exe(ctx2);

            addPointsForCircle(result);

            gnd.getChart().exe(ctx3);

            g2().cir({ ...gnd.past[gnd.past.length - 1] }).exe(ctx2);

            if (gnd.confident) {
                for (let i = 0, max = 0; i < result.length; ++i) {
                    const r = result[i];
                    if (r.x === 0 && r.y === 0) {
                        continue;
                    }
                    const hy = Math.hypot(r.y - gnd.y, r.x - gnd.x);

                    if (hy > max) {
                        nod = r;
                    }
                }

                g2().lin({ x1: gnd.x, y1: gnd.y, x2: nod.x, y2: nod.y })
                    .gnd({ ...gnd })
                    .nod(nod)
                    .exe(ctx2);
            }
        };

        simulation(model, () => step_compare_images(fn));
    </script>
</body>

</html>