<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <script src="https://goessner.github.io/g2/g2.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="./getDirectionalColor.js"></script>
    <script src="./gnd.js"></script>
    <script src="./compare_images.js"></script>
    <script src="../src/simulation.js"></script>

    <b>pendel3_2.html</b>
    <p>Test mit Pendel durch kleinsten ummantelnden Kreis, wenn das Glied sich um mehr als 180° dreht.
        Wie zu sehen ist, ist der vermutete Drehpunkt sehr nah am tatsächlichen Drehpunkt.
    </p>

    <script>
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 149.9, y: 100, base: true },
                { id: 'A1', x: 150, y: 150 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        let gnd = new Gnd();
        let nod; // Endstück des Pendels

        const ws = []; // Sammlung der Winkelbewegungen

        function removeOverlaps(boxes) {
            const mostAccurate = [];
            while (boxes.length) {
                const max = boxes.pop();
                mostAccurate.push(max);
                boxes = boxes.filter(
                    (rec) =>
                        Math.abs(rec.x - max.x) >= 10 ||
                        Math.abs(rec.y - max.y) >= 10
                );
            }
            return mostAccurate;
        }

        const fn = (result) => {
            const filtered = removeOverlaps(result);

            if (filtered.length) last_result = filtered;

            let max = 0;
            let p1;
            let p2;

            const sum = filtered.reduce((pre, cur) => ({
                x: pre.x + cur.x,
                y: pre.y + cur.y,
            }), { x: 0, y: 0 });

            const X = sum.x / filtered.length;
            const Y = sum.y / filtered.length;

            let m;
            let b;

            if (!X || !Y) {
                m = Number.MAX_SAFE_INTEGER;
                b = 0;
            } else {
                const counter = filtered.reduce((pre, cur) =>
                    pre + (cur.x - X) * (cur.y - Y), 0
                );
                const denominator = filtered.reduce((pre, cur) =>
                    pre + (cur.x - X) ** 2, 0
                );

                m = counter / denominator;
                b = Y - m * X;
            }

            g2().clr().exe(ctx2);
            filtered.forEach(e => {
                g2().cir({ x: e.x, y: e.y, r: 0.5 }).exe(ctx2);
            });

            g2().lin({ x1: 0, y1: b, x2: 300, y2: m * 300 + b }).exe(ctx2)
        };

        simulation(model, fn);
    </script>
</body>

</html>