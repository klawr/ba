<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            outline: 2px solid black !important;
        }
    </style>
</head>

<body>
    <p>Test mit Pendel durch kleinsten ummantelnden Kreis, wenn das Glied sich um mehr als 180° dreht.
        Wie zu sehen ist, ist der vermutete Drehpunkt sehr nah am tatsächlichen Drehpunkt.
    </p>

    <input id="btn" type="button" value="Start/Stop"></input>
    <p id="gnd1"></p>
    <p id="gnd2"></p>

    <canvas id="cnv1" width="320" height="180"></canvas>
    <canvas id="cnv2" width="320" height="180"></canvas>
    <canvas id="cnv3" width="320" height="180"></canvas>
    <script src="https://goessner.github.io/g2/g2.js"></script>
    <script src="../third_party/mec2.min.js"></script>
    <script src="./getDirectionalColor.js"></script>
    <script src="./gnd.js"></script>
    <script src="./compare_images.js"></script>

    <script>
        const gnd1 = document.getElementById('gnd1');
        const gnd2 = document.getElementById('gnd2');

        const cnv1 = document.getElementById('cnv1');
        const ctx1 = cnv1.getContext('2d');

        const cnv2 = document.getElementById('cnv2');
        const ctx2 = cnv2.getContext('2d');

        const cnv3 = document.getElementById('cnv3');
        const ctx3 = cnv3.getContext('2d');

        const g = g2().clr().view({ cartesian: true });         // a g2 graphics-object
        const model = {
            id: 'pendulum',
            gravity: true,
            nodes: [
                { id: 'A0', x: 149.9, y: 100, base: true },
                { id: 'A1', x: 150, y: 150 }
            ],
            constraints: [
                { id: 'a', p1: 'A0', p2: 'A1', len: { type: 'const' } }
            ]
        };

        let gnd = new Gnd();
        let nod; // Endstück des Pendels

        const ws = []; // Sammlung der Winkelbewegungen

        function removeOverlaps(boxes) {
            const mostAccurate = [];
            while (boxes.length) {
                const max = boxes.pop();
                mostAccurate.push(max);
                boxes = boxes.filter(
                    (rec) =>
                        Math.abs(rec.x - max.x) >= 10 ||
                        Math.abs(rec.y - max.y) >= 10
                );
            }
            return mostAccurate;
        }

        // simulation
        const simulate = () => {
            const image1 = ctx1.getImageData(0, 0, cnv1.width, cnv1.height).data;
            model.tick(1 / 60); // solve model with fixed stepping
            g.exe(ctx1);         // render its pose on the canvas


            const image2 = ctx1.getImageData(0, 0, cnv1.width, cnv1.height).data;
            const result = removeOverlaps(compare_images(image1, image2, cnv1.width, cnv1.height));

            if (result.length) last_result = result;

            let max = 0;
            let p1;
            let p2;

            const sum = result.reduce((pre, cur) => ({
                x: pre.x + cur.x,
                y: pre.y + cur.y,
            }), { x: 0, y: 0 });

            const X = sum.x / result.length;
            const Y = sum.y / result.length;

            let m;
            let b;

            if (!X || !Y) {
                m = Number.MAX_SAFE_INTEGER;
                b = 0;
            } else {
                const counter = result.reduce((pre, cur) =>
                    pre + (cur.x - X) * (cur.y - Y), 0
                );
                const denominator = result.reduce((pre, cur) =>
                    pre + (cur.x - X) ** 2, 0
                );

                m = counter / denominator;
                b = Y - m * X;
            }

            g2().clr().exe(ctx2);
            result.forEach(e => {
                g2().cir({ x: e.x, y: e.y, r: 0.5 }).exe(ctx2);
            });

            g2().lin({ x1: 0, y1: b, x2: 300, y2: m * 300 + b }).exe(ctx2)

            if (running) {
                requestAnimationFrame(simulate);  // keep calling back
            }
        };

        let running = false;
        const btn = document.getElementById('btn');
        btn.addEventListener('click', () => {
            running = !running;
            running && simulate();  // kick-off the simulation
        });

        mec.model.extend(model);                    // extend the model
        model.init();                               // initialize it
        model.draw(g);                              // append model-graphics to graphics-obj
        simulate();                                 // kick-off the simulation
    </script>
</body>

</html>